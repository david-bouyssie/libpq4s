package com.github.libpq4s.bindings

import scala.language.implicitConversions
import scala.scalanative.unsafe._
import scala.scalanative.unsigned._

import com.github.libpq4s.api._

@link("pq")
@extern
object pq {

  // ADDED BY DBO //
  trait IOidUInt extends Any
  sealed trait IPGcancelStruct extends Any
  sealed trait IPGconnStruct extends Any
  sealed trait IPQconninfoOptionStruct extends Any
  sealed trait IPGresultStruct extends Any
  // END OF ADDED BY DBO //

  object constants {
    val PG_COPYRES_ATTRS: CInt = 1
    val PG_COPYRES_TUPLES: CInt = 2
    val PG_COPYRES_EVENTS: CInt = 4
    val PG_COPYRES_NOTICEHOOKS: CInt = 8
    val PQnoPasswordSupplied: CString = c"fe_sendauth: no password supplied\n"

    val InvalidOid: Oid = 0.toUInt.asInstanceOf[UInt with IOidUInt]
  }

  // Note: these enums generated by scala-native-bindgen were replaced by more complex types in com.github.libpq4s.api

  type ConnStatusType = CUnsignedInt
  /*object ConnStatusType {
    final val CONNECTION_OK: ConnStatusType = 0.toUInt
    final val CONNECTION_BAD: ConnStatusType = 1.toUInt
    final val CONNECTION_STARTED: ConnStatusType = 2.toUInt
    final val CONNECTION_MADE: ConnStatusType = 3.toUInt
    final val CONNECTION_AWAITING_RESPONSE: ConnStatusType = 4.toUInt
    final val CONNECTION_AUTH_OK: ConnStatusType = 5.toUInt
    final val CONNECTION_SETENV: ConnStatusType = 6.toUInt
    final val CONNECTION_SSL_STARTUP: ConnStatusType = 7.toUInt
    final val CONNECTION_NEEDED: ConnStatusType = 8.toUInt
    final val CONNECTION_CHECK_WRITABLE: ConnStatusType = 9.toUInt
    final val CONNECTION_CONSUME: ConnStatusType = 10.toUInt
  }*/

  type PostgresPollingStatusType = CUnsignedInt
  /*object PostgresPollingStatusType {
    final val PGRES_POLLING_FAILED: PostgresPollingStatusType = 0.toUInt
    final val PGRES_POLLING_READING: PostgresPollingStatusType = 1.toUInt
    final val PGRES_POLLING_WRITING: PostgresPollingStatusType = 2.toUInt
    final val PGRES_POLLING_OK: PostgresPollingStatusType = 3.toUInt
    final val PGRES_POLLING_ACTIVE: PostgresPollingStatusType = 4.toUInt
  }*/

  type ExecStatusType = CUnsignedInt
  /*object ExecStatusType {
    final val PGRES_EMPTY_QUERY: ExecStatusType = 0.toUInt
    final val PGRES_COMMAND_OK: ExecStatusType = 1.toUInt
    final val PGRES_TUPLES_OK: ExecStatusType = 2.toUInt
    final val PGRES_COPY_OUT: ExecStatusType = 3.toUInt
    final val PGRES_COPY_IN: ExecStatusType = 4.toUInt
    final val PGRES_BAD_RESPONSE: ExecStatusType = 5.toUInt
    final val PGRES_NONFATAL_ERROR: ExecStatusType = 6.toUInt
    final val PGRES_FATAL_ERROR: ExecStatusType = 7.toUInt
    final val PGRES_COPY_BOTH: ExecStatusType = 8.toUInt
    final val PGRES_SINGLE_TUPLE: ExecStatusType = 9.toUInt
  }*/

  type PGTransactionStatusType = CUnsignedInt
  /*object PGTransactionStatusType {
    final val PQTRANS_IDLE: PGTransactionStatusType = 0.toUInt
    final val PQTRANS_ACTIVE: PGTransactionStatusType = 1.toUInt
    final val PQTRANS_INTRANS: PGTransactionStatusType = 2.toUInt
    final val PQTRANS_INERROR: PGTransactionStatusType = 3.toUInt
    final val PQTRANS_UNKNOWN: PGTransactionStatusType = 4.toUInt
  }*/

  type PGVerbosity = CUnsignedInt
  /*object PGVerbosity {
    final val PQERRORS_TERSE: PGVerbosity = 0.toUInt
    final val PQERRORS_DEFAULT: PGVerbosity = 1.toUInt
    final val PQERRORS_VERBOSE: PGVerbosity = 2.toUInt
  }*/

  type PGContextVisibility = CUnsignedInt
  /*object PGContextVisibility {
    final val PQSHOW_CONTEXT_NEVER: PGContextVisibility = 0.toUInt
    final val PQSHOW_CONTEXT_ERRORS: PGContextVisibility = 1.toUInt
    final val PQSHOW_CONTEXT_ALWAYS: PGContextVisibility = 2.toUInt
  }*/

  type PGPing = CUnsignedInt
  /*object PGPing {
    final val PQPING_OK: PGPing = 0.toUInt
    final val PQPING_REJECT: PGPing = 1.toUInt
    final val PQPING_NO_RESPONSE: PGPing = 2.toUInt
    final val PQPING_NO_ATTEMPT: PGPing = 3.toUInt
  }*/


  type PGErrorField = CChar

  /**
   * Identifiers of error message fields.
   */
  /*object PGErrorFieldIdentifier {
    final val PG_DIAG_SEVERITY: CInt = 'S'
    final val PG_DIAG_SEVERITY_NONLOCALIZED: CInt = 'V'
    final val PG_DIAG_SQLSTATE: CInt = 'C'
    final val PG_DIAG_MESSAGE_PRIMARY: CInt = 'M'
    final val PG_DIAG_MESSAGE_DETAIL: CInt = 'D'
    final val PG_DIAG_MESSAGE_HINT: CInt = 'H'
    final val PG_DIAG_STATEMENT_POSITION: CInt = 'P'
    final val PG_DIAG_INTERNAL_POSITION: CInt = 'p'
    final val PG_DIAG_INTERNAL_QUERY: CInt = 'q'
    final val PG_DIAG_CONTEXT: CInt = 'W'
    final val PG_DIAG_SCHEMA_NAME: CInt = 's'
    final val PG_DIAG_TABLE_NAME: CInt = 't'
    final val PG_DIAG_COLUMN_NAME: CInt = 'c'
    final val PG_DIAG_DATATYPE_NAME: CInt = 'd'
    final val PG_DIAG_CONSTRAINT_NAME: CInt = 'n'
    final val PG_DIAG_SOURCE_FILE: CInt = 'F'
    final val PG_DIAG_SOURCE_LINE: CInt = 'L'
    final val PG_DIAG_SOURCE_FUNCTION: CInt = 'R'
  }*/

  type __off_t = CLong
  type __off64_t = CLong
  // FIXME: find a way to deal with the stdio FILE struct
  //type struct__IO_FILE = CStruct29[CInt, CString, CString, CString, CString, CString, CString, CString, CString, CString, CString, CString, Ptr[struct__IO_marker], Ptr[Byte], CInt, CInt, __off_t, CUnsignedShort, CSignedChar, CArray[CChar, Nat._1], Ptr[Byte], __off64_t, Ptr[Byte], Ptr[Byte], Ptr[Byte], Ptr[Byte], CSize, CInt, CArray[CChar, Nat.Digit[Nat._2, Nat._0]]]
  type FILE = Byte // struct__IO_FILE
  type struct__IO_marker = CStruct3[Ptr[Byte], Ptr[Byte], CInt]
  type Oid = CUnsignedInt with IOidUInt
  type pg_int64 = CLong
  type struct_pg_conn = CStruct0 // incomplete type
  //type PGconn = struct_pg_conn with IPGconnStruct
  type PGconn = IPGconnStruct
  type struct_pg_result = CStruct0 // incomplete type
  //type PGresult = struct_pg_result with IPGresultStruct
  type PGresult = IPGresultStruct
  type struct_pg_cancel = CStruct0 // incomplete type
  //type PGcancel = struct_pg_cancel with IPGcancelStruct
  type PGcancel = IPGcancelStruct
  type struct_pgNotify = CStruct4[CString, CInt, CString, Ptr[Byte]]
  type PGnotify = struct_pgNotify
  type PQnoticeReceiver = CFuncPtr2[Ptr[Byte], Ptr[PGresult], Unit]
  type PQnoticeProcessor = CFuncPtr2[Ptr[Byte], CString, Unit]
  type pqbool = CChar
  type struct__PQprintOpt = CStruct10[pqbool, pqbool, pqbool, pqbool, pqbool, pqbool, CString, CString, CString, Ptr[CString]]
  type PQprintOpt = struct__PQprintOpt
  type struct__PQconninfoOption = CStruct7[CString, CString, CString, CString, CString, CString, CInt]
  type PQconninfoOption = struct__PQconninfoOption with IPQconninfoOptionStruct
  type union_anonymous_1 = CArray[Byte, Nat._8]
  type struct_PQArgBlock = CStruct3[CInt, CInt, union_anonymous_1]
  type PQArgBlock = struct_PQArgBlock
  type struct_pgresAttDesc = CStruct7[CString, Oid, CInt, CInt, Oid, CInt, CInt]
  type PGresAttDesc = struct_pgresAttDesc
  type pgthreadlock_t = CFuncPtr1[CInt, Unit]

  /**
   * PQconnectStart
   *
   * Begins the establishment of a connection to a postgres backend through the
   * postmaster using connection information in a string.
   *
   * See comment for PQconnectdb for the definition of the string format.
   *
   * Returns a PGconn*. If NULL is returned, a malloc error has occurred, and you
   * should not attempt to proceed with this connection. If the status field of the
   * connection returned is CONNECTION_BAD, an error has occurred. In this case you
   * should call PQfinish on the result, (perhaps inspecting the error message
   * first). Other fields of the structure may not be valid if that occurs. If the
   * status field is not CONNECTION_BAD, then this stage has succeeded - call
   * PQconnectPoll, using select(2) to see when this is necessary.
   *
   * See PQconnectPoll for more info.
   *
   * Allocate memory for the conn structure
   *
   * Parse the conninfo string
   *
   * Compute derived options
   *
   * Connect to the database
   *
   * Just in case we failed to set it in connectDBStart
   */
  def PQconnectStart(conninfo: CString): Ptr[PGconn] = extern

  /**
   * PQconnectStartParams
   *
   * Begins the establishment of a connection to a postgres backend through the
   * postmaster using connection information in a struct.
   *
   * See comment for PQconnectdbParams for the definition of the string format.
   *
   * Returns a PGconn*. If NULL is returned, a malloc error has occurred, and you
   * should not attempt to proceed with this connection. If the status field of the
   * connection returned is CONNECTION_BAD, an error has occurred. In this case you
   * should call PQfinish on the result, (perhaps inspecting the error message
   * first). Other fields of the structure may not be valid if that occurs. If the
   * status field is not CONNECTION_BAD, then this stage has succeeded - call
   * PQconnectPoll, using select(2) to see when this is necessary.
   *
   * See PQconnectPoll for more info.
   *
   * Allocate memory for the conn structure
   *
   * Parse the conninfo arrays
   *
   * errorMessage is already set
   *
   * Move option values into conn structure
   *
   * Free the option info - all is in conn now
   *
   * Compute derived options
   *
   * Connect to the database
   *
   * Just in case we failed to set it in connectDBStart
   */
  def PQconnectStartParams(keywords: Ptr[CString], values: Ptr[CString], expand_dbname: CInt): Ptr[PGconn] = extern

  /**
   *  PQconnectPoll
   *
   * Poll an asynchronous connection.
   *
   * Returns a PostgresPollingStatusType. Before calling this function, use select(2)
   * to determine when data has arrived..
   *
   * You must call PQfinish whether or not this fails.
   *
   * This function and PQconnectStart are intended to allow connections to be made
   * without blocking the execution of your program on remote I/O. However, there are
   * a number of caveats:
   *
   * o If you call PQtrace, ensure that the stream object into which you trace will
   * not block. o If you do not supply an IP address for the remote host (i.e. you
   * supply a host name instead) then PQconnectStart will block on gethostbyname. You
   * will be fine if using Unix sockets (i.e. by supplying neither a host name nor a
   * host address). o If your backend wants to use Kerberos authentication then you
   * must supply both a host name and a host address, otherwise this function may
   * block on gethostname.
   *
   */
  def PQconnectPoll(conn: Ptr[PGconn]): PostgresPollingStatusType = extern

  /**
   * PQconnectdb
   *
   * establishes a connection to a postgres backend through the postmaster using
   * connection information in a string.
   *
   * The conninfo string is either a whitespace-separated list of
   *
   *     option = value
   *
   * definitions or a URI (refer to the documentation for details.) Value might be a
   * single value containing no whitespaces or a single quoted string. If a single
   * quote should appear anywhere in the value, it must be escaped with a backslash
   * like \\'
   *
   * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL if a
   * memory allocation failed. If the status field of the connection returned is
   * CONNECTION_BAD, then some fields may be null'ed out instead of having valid
   * values.
   *
   * You should call PQfinish (if conn is not NULL) regardless of whether this call
   * succeeded.
   */
  def PQconnectdb(conninfo: CString): Ptr[PGconn] = extern

  /**
   * Connecting to a Database
   *
   * There are now six different ways a user of this API can connect to the database.
   * Two are not recommended for use in new code, because of their lack of
   * extensibility with respect to the passing of options to the backend. These are
   * PQsetdb and PQsetdbLogin (the former now being a macro to the latter).
   *
   * If it is desired to connect in a synchronous (blocking) manner, use the function
   * PQconnectdb or PQconnectdbParams. The former accepts a string of option = value
   * pairs (or a URI) which must be parsed; the latter takes two NULL terminated
   * arrays instead.
   *
   * To connect in an asynchronous (non-blocking) manner, use the functions
   * PQconnectStart or PQconnectStartParams (which differ in the same way as
   * PQconnectdb and PQconnectdbParams) and PQconnectPoll.
   *
   * Internally, the static functions connectDBStart, connectDBComplete are part of
   * the connection procedure. PQconnectdbParams
   *
   * establishes a connection to a postgres backend through the postmaster using
   * connection information in two arrays.
   *
   * The keywords array is defined as
   *     const char *params[] = {\"option1\", \"option2\", NULL}
   *
   * The values array is defined as
   *     const char *values[] = {\"value1\", \"value2\", NULL}
   *
   * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL if a
   * memory allocation failed. If the status field of the connection returned is
   * CONNECTION_BAD, then some fields may be null'ed out instead of having valid
   * values.
   *
   * You should call PQfinish (if conn is not NULL) regardless of whether this call
   * succeeded.
   */
  def PQconnectdbParams(keywords: Ptr[CString], values: Ptr[CString], expand_dbname: CInt): Ptr[PGconn] = extern

  /**
   *  PQsetdbLogin: Makes a new connection to the database server.
   *
   * This is the predecessor of PQconnectdb with a fixed set of parameters.
   * It has the same functionality except that the missing parameters will always take on default values.
   * Write NULL or an empty string for any one of the fixed parameters that is to be defaulted.
   *
   * If the dbName contains an = sign or has a valid connection URI prefix,
   * it is taken as a conninfo string in exactly the same way as if it had been passed to PQconnectdb,
   * and the remaining parameters are then applied as specified for PQconnectdbParams.
   */
  def PQsetdbLogin(pghost: CString, pgport: CString, pgoptions: CString, pgtty: CString, dbName: CString, login: CString, pwd: CString): Ptr[PGconn] = extern

  /**
   * PQfinish: properly close a connection to the backend. Also frees the PGconn data
   * structure so it shouldn't be re-used after this.
   */
  def PQfinish(conn: Ptr[PGconn]): Unit = extern

  /**
   * Returns the default connection options.
   *
   * Returns a connection options array. This can be used to determine all possible PQconnectdb options and their current default values.
   * The return value points to an array of PQconninfoOption structures, which ends with an entry having a null keyword pointer.
   * The null pointer is returned if memory could not be allocated.
   * Note that the current default values (val fields) will depend on environment variables and other context.
   * A missing or invalid service file will be silently ignored. Callers must treat the connection options data as read-only.
   *
   * After processing the options array, free it by passing it to PQconninfoFree.
   * If this is not done, a small amount of memory is leaked for each call to PQconndefaults.
   */
  def PQconndefaults(): Ptr[PQconninfoOption] = extern

  /**
   * PQconninfoParse
   *
   * Returns parsed connection options from the provided connection string.
   *
   * Parses a connection string like PQconnectdb() and returns the resulting options as an array;
   * or returns NULL if there is a problem with the connection string.
   * This function can be used to extract the PQconnectdb options in the provided connection string (not any possible default values).
   * The return value points to an array of PQconninfoOption structures, which ends with an entry having a null keyword pointer.
   *
   * All legal options will be present in the result array, but the PQconninfoOption for any option not present in the connection string
   * will have val set to NULL; default values are not inserted.
   *
   * If errmsg is not NULL, then *errmsg is set to NULL on success, else to a malloc'd error string explaining the problem.
   * It is also possible for *errmsg to be set to NULL and the function to return NULL; this indicates an out-of-memory condition.
   *
   * After processing the options array (which is dynamically allocated), free it by passing it to PQconninfoFree.
   * If this is not done, some memory is leaked for each call to PQconninfoParse.
   * Conversely, if an error occurs and errmsg is not NULL, be sure to free the error string using PQfreemem.
   *
   */
  def PQconninfoParse(conninfo: CString, errmsg: Ptr[CString]): Ptr[PQconninfoOption] = extern

  /**
   * Returns the connection options used by a live connection.
   *
   * Returns a connection options array.
   * This can be used to determine all possible PQconnectdb options and the values that were used to connect to the server.
   * The return value points to an array of PQconninfoOption structures, which ends with an entry having a null keyword pointer.
   * All notes above for PQconndefaults also apply to the result of PQconninfo.
   */
  def PQconninfo(conn: Ptr[PGconn]): Ptr[PQconninfoOption] = extern
  def PQconninfoFree(connOptions: Ptr[PQconninfoOption]): Unit = extern

  /**
   * PQresetStart: resets the connection to the backend closes the existing
   * connection and makes a new one Returns 1 on success, 0 on failure.
   */
  def PQresetStart(conn: Ptr[PGconn]): CInt = extern

  /**
   * PQresetPoll: resets the connection to the backend closes the existing connection
   * and makes a new one
   *
   * Notify event procs of successful reset. We treat an event proc failure as
   * disabling the connection ... good idea?
   */
  def PQresetPoll(conn: Ptr[PGconn]): PostgresPollingStatusType = extern

  /**
   * PQreset: Resets the communication channel to the server.
   *
   * This function will close the connection to the server and attempt to reestablish a new connection to the same server,
   * using all the same parameters previously used. This might be useful for error recovery if a working connection is lost.
   */
  def PQreset(conn: Ptr[PGconn]): Unit = extern

  /**
   * PQgetCancel: Creates a data structure containing the information needed to cancel a command issued through a particular database connection.
   *
   * PQgetCancel creates a PGcancel object given a PGconn connection object.
   * It will return NULL if the given conn is NULL or an invalid connection.
   * The PGcancel object is an opaque structure that is not meant to be accessed directly by the application;
   * it can only be passed to PQcancel or PQfreeCancel.
   *
   * A copy is needed to be able to cancel a running query from a different thread.
   * If the same structure is used all structure members would have to be
   * individually locked (if the entire structure was locked, it would be impossible
   * to cancel a synchronous query because the structure would have to stay locked
   * for the duration of the query).
   */
  def PQgetCancel(conn: Ptr[PGconn]): Ptr[PGcancel] = extern

  /**
   * PQfreeCancel: free a cancel structure
   */
  def PQfreeCancel(cancel: Ptr[PGcancel]): Unit = extern

  /**
   * PQcancel: request query cancel
   *
   * Returns true if able to send the cancel request, false if not.
   *
   * On failure, an error message is stored in *errbuf, which must be of size
   * errbufsize (recommended size is 256 bytes). *errbuf is not changed on success
   * return.
   */
  def PQcancel(cancel: Ptr[PGcancel], errbuf: CString, errbufsize: CInt): CInt = extern

  /**
   * PQrequestCancel: old, not thread-safe function for requesting query cancel
   *
   * Returns true if able to send the cancel request, false if not.
   *
   * On failure, the error message is saved in conn->errorMessage; this means that
   * this can't be used when there might be other active operations on the connection
   * object.
   *
   */
  //@deprecated def PQrequestCancel(conn: Ptr[PGconn]): CInt = extern

  /*
   * The following functions return parameter values established at connection.
   * These values are fixed for the life of the PGconn object.
   */

  /** Returns the database name of the connection. */
  def PQdb(conn: Ptr[PGconn]): CString = extern
  /** Returns the user name of the connection. */
  def PQuser(conn: Ptr[PGconn]): CString = extern
  /** Returns the password of the connection. */
  def PQpass(conn: Ptr[PGconn]): CString = extern
  /** Returns the host name of the connection. */
  def PQhost(conn: Ptr[PGconn]): CString = extern
  /** Returns the port of the connection. */
  def PQport(conn: Ptr[PGconn]): CString = extern
  /* Returns the debug TTY of the connection (obsolete but kept for backwards compatibility). */
  //@deprecated def PQtty(conn: Ptr[PGconn]): CString = extern
  /** Returns the command-line options passed in the connection request. */
  def PQoptions(conn: Ptr[PGconn]): CString = extern

  /*
   * The following functions return status data that can change as operations are executed on the PGconn object.
   */

  /**
   * Returns the status of the connection.
   *
   * The status can be one of a number of values.
   * However, only two of these are seen outside of an asynchronous connection procedure: CONNECTION_OK and CONNECTION_BAD.
   * A good connection to the database has the status CONNECTION_OK.
   * A failed connection attempt is signaled by status CONNECTION_BAD.
   * Ordinarily, an OK status will remain so until PQfinish,
   * but a communications failure might result in the status changing to CONNECTION_BAD prematurely.
   * In that case the application could try to recover by calling PQreset.
   *
   * See the entry for PQconnectStart and PQconnectPoll with regards to other status codes that might be seen.
   */
  def PQstatus(conn: Ptr[PGconn]): ConnStatusType = extern

  /**
   * Returns the current in-transaction status of the server.
   *
   * The status can be PQTRANS_IDLE (currently idle), PQTRANS_ACTIVE (a command is in progress),
   * PQTRANS_INTRANS (idle, in a valid transaction block), or PQTRANS_INERROR (idle, in a failed transaction block).
   *
   * PQTRANS_UNKNOWN is reported if the connection is bad.
   * PQTRANS_ACTIVE is reported only when a query has been sent to the server and not yet completed.
   */
  def PQtransactionStatus(conn: Ptr[PGconn]): PGTransactionStatusType = extern

  /**
   * Looks up a current parameter setting of the server.
   *
   * Certain parameter values are reported by the server automatically at connection startup or whenever their values change.
   * PQparameterStatus can be used to interrogate these settings.
   * It returns the current value of a parameter if known, or NULL if the parameter is not known.
   *
   * Parameters reported as of the current release include server_version, server_encoding, client_encoding, application_name,
   * is_superuser, session_authorization, DateStyle, IntervalStyle, TimeZone, integer_datetimes, and standard_conforming_strings.
   * Sserver_encoding, TimeZone, and integer_datetimes were not reported by releases before 8.0;
   * standard_conforming_strings was not reported by releases before 8.1;
   * IntervalStyle was not reported by releases before 8.4;
   * application_name was not reported by releases before 9.0.
   * Note that server_version, server_encoding and integer_datetimes cannot change after startup.
   *
   * Pre-3.0-protocol servers do not report parameter settings, but libpq includes logic to obtain values for server_version and client_encoding anyway.
   * Applications are encouraged to use PQparameterStatus rather than ad hoc code to determine these values.
   * (Beware however that on a pre-3.0 connection, changing client_encoding via SET after connection startup will not be reflected by PQparameterStatus.)
   * For server_version, see also PQserverVersion, which returns the information in a numeric form that is much easier to compare against.
   *
   * If no value for standard_conforming_strings is reported, applications can assume it is off, that is, backslashes are treated as escapes in string literals.
   * Also, the presence of this parameter can be taken as an indication that the escape string syntax (E'...') is accepted.
   *
   * Although the returned pointer is declared const, it in fact points to mutable storage associated with the PGconn structure.
   * It is unwise to assume the pointer will remain valid across queries.
   */
  def PQparameterStatus(conn: Ptr[PGconn], paramName: CString): CString = extern

  def PQlibVersion(): CInt = extern

  /**
   * Interrogates the frontend/backend protocol being used.
   *
   * Applications might wish to use this function to determine whether certain features are supported.
   * Currently, the possible values are 2 (2.0 protocol), 3 (3.0 protocol), or zero (connection bad).
   * The protocol version will not change after connection startup is complete, but it could theoretically change during a connection reset.
   * The 3.0 protocol will normally be used when communicating with PostgreSQL 7.4 or later servers; pre-7.4 servers support only protocol 2.0.
   * (Protocol 1.0 is obsolete and not supported by libpq.)
   */
  def PQprotocolVersion(conn: Ptr[PGconn]): CInt = extern

  /**
   * Returns an integer representing the server version.
   *
   * Applications might use this function to determine the version of the database server they are connected to.
   * The result is formed by multiplying the server's major version number by 10000 and adding the minor version number.
   * For example, version 10.1 will be returned as 100001, and version 11.0 will be returned as 110000.
   * Zero is returned if the connection is bad.
   *
   * Prior to major version 10, PostgreSQL used three-part version numbers in which the first two parts together represented the major version.
   * For those versions, PQserverVersion uses two digits for each part;
   * for example version 9.1.5 will be returned as 90105, and version 9.2.0 will be returned as 90200.
   *
   * Therefore, for purposes of determining feature compatibility,
   * applications should divide the result of PQserverVersion by 100 not 10000 to determine a logical major version number.
   * In all release series, only the last two digits differ between minor releases (bug-fix releases).
   */
  def PQserverVersion(conn: Ptr[PGconn]): CInt = extern

  /**
   * Returns the error message most recently generated by an operation on the connection.
   *
   * Nearly all libpq functions will set a message for PQerrorMessage if they fail.
   * Note that by libpq convention, a nonempty PQerrorMessage result can consist of multiple lines, and will include a trailing newline.
   * The caller should not free the result directly. It will be freed when the associated PGconn handle is passed to PQfinish.
   * The result string should not be expected to remain the same across operations on the PGconn structure.
   *
   */
  def PQerrorMessage(conn: Ptr[PGconn]): CString = extern

  /**
   * Obtains the file descriptor number of the connection socket to the server.
   *
   * A valid descriptor will be greater than or equal to 0; a result of -1 indicates that no server connection is currently open.
   * This will not change during normal operation, but could change during connection setup or reset.
   *
   * In Windows, socket values are unsigned, and an invalid socket value
   * (INVALID_SOCKET) is ~0, which equals -1 in comparisons (with no compiler
   * warning). Ideally we would return an unsigned value for PQsocket() on Windows,
   * but that would cause the function's return value to differ from Unix, so we just
   * return -1 for invalid sockets. http://msdn.microsoft.com/en-
   * us/library/windows/desktop/cc507522%28v=vs.85%29.aspx
   * http://stackoverflow.com/questions/10817252/why-is-invalid-socket-defined-
   * as-0-in-winsock2-h-c
   */
  def PQsocket(conn: Ptr[PGconn]): CInt = extern

  /**
   * Returns the process ID (PID) of the backend process handling this connection.
   *
   * The backend PID is useful for debugging purposes and for comparison to NOTIFY messages (which include the PID of the notifying backend process).
   * Note that the PID belongs to a process executing on the database server host, not the local host!
   */
  def PQbackendPID(conn: Ptr[PGconn]): CInt = extern

  /**
   * Returns true (1) if the connection authentication method required a password, but none was available. Returns false (0) if not.
   *
   * This function can be applied after a failed connection attempt to decide whether to prompt the user for a password.
   */
  def PQconnectionNeedsPassword(conn: Ptr[PGconn]): CInt = extern

  /**
   * Returns true (1) if the connection authentication method used a password. Returns false (0) if not.
   *
   * This function can be applied after either a failed or successful connection attempt to detect whether the server demanded a password.
   */
  def PQconnectionUsedPassword(conn: Ptr[PGconn]): CInt = extern

  /**
   * Returns the client encoding.
   *
   * ote that it returns the encoding ID, not a symbolic string such as EUC_JP.
   * To convert an encoding ID to an encoding name, you can call pg_encoding_to_char().
   */
  def PQclientEncoding(conn: Ptr[PGconn]): CInt = extern

  /**
   * Sets the client encoding.
   *
   * The current encoding for this connection can be determined by using PQclientEncoding.
   *
   * @param conn a connection to the server
   * @param encoding the encoding you want to use
   * @return 0 if the function successfully sets the encoding otherwise -1
   */
  def PQsetClientEncoding(conn: Ptr[PGconn], encoding: CString): CInt = extern

  /**
   * ENABLE_THREAD_SAFETY WIN32
   * ------------------------------------------------------------ Procedures common
   * to all secure sessions
   * ------------------------------------------------------------
   */
  def PQsslInUse(conn: Ptr[PGconn]): CInt = extern
  def PQsslStruct(conn: Ptr[PGconn], struct_name: CString): Ptr[Byte] = extern

  /**
   * unknown attribute
   */
  def PQsslAttribute(conn: Ptr[PGconn], attribute_name: CString): CString = extern
  def PQsslAttributeNames(conn: Ptr[PGconn]): Ptr[CString] = extern

  /**
   * Dummy versions of SSL info functions, when built without SSL support
   */
  def PQgetssl(conn: Ptr[PGconn]): Ptr[Byte] = extern

  /**
   * Exported function to allow application to tell us it's already initialized.
   */
  def PQinitSSL(do_init: CInt): Unit = extern

  /**
   * Exported function to allow application to tell us it's already initialized.
   * OpenSSL and/or libcrypto.
   */
  def PQinitOpenSSL(do_ssl: CInt, do_crypto: CInt): Unit = extern

  /**
   * Determines the verbosity of messages returned by PQerrorMessage and PQresultErrorMessage.
   *
   * PQsetErrorVerbosity sets the verbosity mode, returning the connection's previous setting.
   * In TERSE mode, returned messages include severity, primary text, and position only; this will normally fit on a single line.
   * The DEFAULT mode produces messages that include the above plus any detail, hint, or context fields (these might span multiple lines).
   * The VERBOSE mode includes all available fields.
   * The SQLSTATE mode includes only the error severity and the SQLSTATE error code, if one is available (if not, the output is like TERSE mode).
   *
   * Changing the verbosity setting does not affect the messages available from already-existing PGresult objects, only subsequently-created ones.
   * But see PQresultVerboseErrorMessage if you want to print a previous error with a different verbosity.
   *
   * @return the previous setting
   */
  def PQsetErrorVerbosity(conn: Ptr[PGconn], verbosity: PGVerbosity): PGVerbosity = extern

  /**
   * Determines the handling of CONTEXT fields in messages returned by PQerrorMessage and PQresultErrorMessage.
   *
   * PQsetErrorContextVisibility sets the context display mode, returning the connection's previous setting.
   * This mode controls whether the CONTEXT field is included in messages.
   * The NEVER mode never includes CONTEXT, while ALWAYS always includes it if available.
   * In ERRORS mode (the default), CONTEXT fields are included only in error messages, not in notices and warnings.
   * However, if the verbosity setting is TERSE or SQLSTATE, CONTEXT fields are omitted regardless of the context display mode.
   *
   * Changing this mode does not affect the messages available from already-existing PGresult objects, only subsequently-created ones.
   * But see PQresultVerboseErrorMessage if you want to print a previous error with a different display mode.
   *
   * @return the previous setting
   */
  def PQsetErrorContextVisibility(conn: Ptr[PGconn], show_context: PGContextVisibility): PGContextVisibility = extern

  /**
   * Enables tracing of the client/server communication to a debugging file stream.
   *
   * Note: On Windows, if the libpq library and an application are compiled with different flags,
   * this function call will crash the application because the internal representation of the FILE pointers differ.
   * Specifically, multithreaded/single-threaded, release/debug, and static/dynamic flags
   * should be the same for the library and all applications using that library.
   */
  def PQtrace(conn: Ptr[PGconn], debug_port: Ptr[FILE]): Unit = extern
  /** Disables tracing started by PQtrace. */
  def PQuntrace(conn: Ptr[PGconn]): Unit = extern

  def PQsetNoticeReceiver(conn: Ptr[PGconn], proc: CFuncPtr2[Ptr[Byte], Ptr[PGresult], Unit], arg: Ptr[Byte]): CFuncPtr2[Ptr[Byte], Ptr[PGresult], Unit] = extern
  def PQsetNoticeProcessor(conn: Ptr[PGconn], proc: CFuncPtr2[Ptr[Byte], CString, Unit], arg: Ptr[Byte]): CFuncPtr2[Ptr[Byte], CString, Unit] = extern

  /**
   * PQexec sends a query to the backend and packages up the result in a PGresult.
   *
   * If the query was not even sent, return NULL; conn->errorMessage is set to a
   * relevant message. If the query was sent, a new PGresult is returned (which could
   * indicate either success or failure). The user is responsible for freeing the
   * PGresult via PQclear() when done with it.
   */
  def PQexec(conn: Ptr[PGconn], query: CString): Ptr[PGresult] = extern

  /**
   * PQexecParams is like PQexec, but use protocol 3.0 so we can pass parameters.
   *
   * It submits a command to the server and waits for the result, with the ability to pass parameters separately from the SQL command text.
   * The primary advantage of PQexecParams over PQexec is that parameter values can be separated from the command string, thus avoiding the need for tedious and error-prone quoting and escaping.
   * Unlike PQexec, PQexecParams allows at most one SQL command in the given string (there can be semicolons in it, but not more than one nonempty command).
   * This is a limitation of the underlying protocol, but has some usefulness as an extra defense against SQL-injection attacks.
   *
   * The function arguments are:
   *
   * @param conn The connection object to send the command through.
   * @param command The SQL command string to be executed. If parameters are used, they are referred to in the command string as $1, $2, etc.
   * @param nParams The number of parameters supplied; it is the length of the arrays paramTypes[], paramValues[], paramLengths[], and paramFormats[]. (The array pointers can be NULL when nParams is zero.)
   * @param paramTypes Specifies, by OID, the data types to be assigned to the parameter symbols. If paramTypes is NULL, or any particular element in the array is zero, the server infers a data type for the parameter symbol in the same way it would do for an untyped literal string.
   * @param paramValues Specifies the actual values of the parameters. A null pointer in this array means the corresponding parameter is null; otherwise the pointer points to a zero-terminated text string (for text format) or binary data in the format expected by the server (for binary format).
   * @param paramLengths Specifies the actual data lengths of binary-format parameters. It is ignored for null parameters and text-format parameters. The array pointer can be null when there are no binary parameters.
   * @param paramFormats Specifies whether parameters are text (put a zero in the array entry for the corresponding parameter) or binary (put a one in the array entry for the corresponding parameter). If the array pointer is null then all parameters are presumed to be text strings.
   * Values passed in binary format require knowledge of the internal representation expected by the backend. For example, integers must be passed in network byte order.
   * Passing numeric values requires knowledge of the server storage format, as implemented in src/backend/utils/adt/numeric.c::numeric_send() and src/backend/utils/adt/numeric.c::numeric_recv().
   * @param resultFormat Specify zero to obtain results in text format, or one to obtain results in binary format. (There is not currently a provision to obtain different result columns in different formats, although that is possible in the underlying protocol.)
   *
   */
  def PQexecParams(conn: Ptr[PGconn], command: CString, nParams: CInt, paramTypes: Ptr[Oid], paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): Ptr[PGresult] = extern

  /**
   * PQprepare Creates a prepared statement by issuing a v3.0 parse message.
   *
   * If the query was not even sent, return NULL; conn->errorMessage is set to a
   * relevant message. If the query was sent, a new PGresult is returned (which could
   * indicate either success or failure). The user is responsible for freeing the
   * PGresult via PQclear() when done with it.
   */
  def PQprepare(conn: Ptr[PGconn], stmtName: CString, query: CString, nParams: CInt, paramTypes: Ptr[Oid]): Ptr[PGresult] = extern

  /**
   * PQexecPrepared Like PQexec, but execute a previously prepared statement, using
   * protocol 3.0 so we can pass parameters
   */
  def PQexecPrepared(conn: Ptr[PGconn], stmtName: CString, nParams: CInt, paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): Ptr[PGresult] = extern

  /**
   * PQsendQuery Submit a query, but don't wait for it to finish
   *
   * Returns: 1 if successfully submitted 0 if error (conn->errorMessage is set)
   *
   * check the argument
   *
   * construct the outgoing Query message
   *
   * error message should be set up already
   *
   * remember we are using simple query protocol
   *
   * and remember the query text too, if possible
   *
   * if insufficient memory, last_query just winds up NULL
   *
   * Give the data a push. In nonblock mode, don't complain if we're unable to send
   * it all; PQgetResult() will do any additional flushing needed.
   *
   * error message should be set up already
   *
   * OK, it's launched!
   */
  def PQsendQuery(conn: Ptr[PGconn], query: CString): CInt = extern

  /**
   * PQsendQueryParams Like PQsendQuery, but use protocol 3.0 so we can pass
   * parameters
   *
   * check the arguments
   *
   * use unnamed statement
   */
  def PQsendQueryParams(conn: Ptr[PGconn], command: CString, nParams: CInt, paramTypes: Ptr[Oid], paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): CInt = extern

  /**
   * PQsendPrepare Submit a Parse message, but don't wait for it to finish
   *
   * Returns: 1 if successfully submitted 0 if error (conn->errorMessage is set)
   *
   * check the arguments
   *
   * This isn't gonna work on a 2.0 server
   *
   * construct the Parse message
   *
   * construct the Sync message
   *
   * remember we are doing just a Parse
   *
   * and remember the query text too, if possible
   *
   * if insufficient memory, last_query just winds up NULL
   *
   * Give the data a push. In nonblock mode, don't complain if we're unable to send
   * it all; PQgetResult() will do any additional flushing needed.
   *
   * OK, it's launched!
   *
   * error message should be set up already
   */
  def PQsendPrepare(conn: Ptr[PGconn], stmtName: CString, query: CString, nParams: CInt, paramTypes: Ptr[Oid]): CInt = extern

  /**
   * PQsendQueryPrepared Like PQsendQuery, but execute a previously prepared
   * statement, using protocol 3.0 so we can pass parameters
   *
   * check the arguments
   *
   * no command to parse
   *
   * no param types
   */
  def PQsendQueryPrepared(conn: Ptr[PGconn], stmtName: CString, nParams: CInt, paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): CInt = extern

  /**
   * Select row-by-row processing mode
   *
   * Only allow setting the flag when we have launched a query and not yet received
   * any results.
   *
   * OK, set flag
   */
  def PQsetSingleRowMode(conn: Ptr[PGconn]): CInt = extern

  /**
   * PQgetResult Get the next PGresult produced by a query. Returns NULL if no query
   * work remains or an error has occurred (e.g. out of memory).
   *
   * Parse any available data, if our state permits.
   *
   * If not ready to return something, block until we are.
   *
   * If data remains unsent, send it. Else we might be waiting for the result of a
   * command the backend hasn't even got yet.
   *
   * Wait for some more data, and load it. (Note: if the connection has been lost,
   * pqWait should return immediately because the socket should be read-ready, either
   * with the last server data or with an EOF indication. We expect therefore that
   * this won't result in any undue delay in reporting a previous write failure.)
   *
   * conn->errorMessage has been set by pqWait or pqReadData. We want to append it to
   * any already-received error message.
   *
   * Parse it.
   *
   * If we had a write error, but nothing above obtained a query result or detected a
   * read error, report the write error.
   *
   * Return the appropriate thing.
   *
   * query is complete
   *
   * Set the state back to BUSY, allowing parsing to proceed.
   */
  def PQgetResult(conn: Ptr[PGconn]): Ptr[PGresult] = extern

  /**
   * PQisBusy Return true if PQgetResult would block waiting for input.
   *
   * Parse any available data, if our state permits.
   *
   * PQgetResult will return immediately in all states except BUSY, or if we had a
   * write failure.
   */
  def PQisBusy(conn: Ptr[PGconn]): CInt = extern

  /**
   * Consume any available input from the backend.
   *
   * PQconsumeInput can be called even if the application is not prepared to deal with a result or notification just yet.
   * The function will read available data and save it in a buffer, thereby causing a select() read-ready indication to go away.
   * The application can thus use PQconsumeInput to clear the select() condition immediately, and then examine the results at leisure.
   *
   * PQconsumeInput normally returns 1 indicating “no error”, but returns 0 if there was some kind of trouble (in which case PQerrorMessage can be consulted).
   * Note that the result does not say whether any input data was actually collected.
   * After calling PQconsumeInput, the application can check PQisBusy and/or PQnotifies to see if their state has changed.
   *
   */
  def PQconsumeInput(conn: Ptr[PGconn]): CInt = extern

  /**
   * PQnotifies returns a PGnotify* structure of the latest async notification that
   * has not yet been handled
   *
   * returns NULL, if there is currently no unhandled async notification from the
   * backend
   *
   * the CALLER is responsible for FREE'ing the structure returned
   *
   * Note that this function does not read any new data from the socket; so usually,
   * caller should call PQconsumeInput() first.
   *
   * Parse any available data to see if we can extract NOTIFY messages.
   *
   * don't let app see the internal state
   */
  def PQnotifies(conn: Ptr[PGconn]): Ptr[PGnotify] = extern

  /**
   * Sends data to the server during COPY_IN state.
   *
   * Transmits the COPY data in the specified buffer, of length nbytes, to the server.
   * The result is 1 if the data was queued, zero if it was not queued because of full buffers (this will only happen in nonblocking mode),
   * or -1 if an error occurred. (Use PQerrorMessage to retrieve details if the return value is -1.
   * If the value is zero, wait for write-ready and try again.)
   *
   * The application can divide the COPY data stream into buffer loads of any convenient size.
   * Buffer-load boundaries have no semantic significance when sending.
   * The contents of the data stream must match the data format expected by the COPY command; see COPY for details.
   *
   * @return 1 if successful, 0 if data could not be sent (only possible in nonblocking mode), or -1 if an error occurs.
   *
   */
  def PQputCopyData(conn: Ptr[PGconn], buffer: Ptr[Byte], nbytes: CInt): CInt = extern

  /**
   * Sends end-of-data indication to the server during COPY_IN state.
   *
   * Ends the COPY_IN operation successfully if errormsg is NULL.
   * If errormsg is not NULL then the COPY is forced to fail, with the string pointed to by errormsg used as the error message.
   * One should not assume that this exact error message will come back from the server, however,
   * as the server might have already failed the COPY for its own reasons.
   * Also note that the option to force failure does not work when using pre-3.0-protocol connections.
   *
   * The result is 1 if the termination message was sent;
   * or in nonblocking mode,this may only indicate that the termination message was successfully queued.
   *
   * In nonblocking mode, to be certain that the data has been sent,
   * you should next wait for write-ready and call PQflush, repeating until it returns zero.
   * Zero indicates that the function could not queue the termination message because of full buffers.
   * This will only happen in nonblocking mode (in this case, wait for write-ready and try the PQputCopyEnd call again).
   *
   * If a hard error occurs, -1 is returned; you can use PQerrorMessage to retrieve details.
   *
   * After successfully calling PQputCopyEnd, call PQgetResult to obtain the final result status of the COPY command.
   * One can wait for this result to be available in the usual way. Then return to normal operation.
   *
   * @return 1 if successful, 0 if data could not be sent (only possible in nonblocking mode), or -1 if an error occurs.
   *
   */
  def PQputCopyEnd(conn: Ptr[PGconn], errormsg: CString): CInt = extern

  /**
   * Receives data from the server during COPY_OUT state.
   *
   * Attempts to obtain another row of data from the server during a COPY.
   * Data is always returned one data row at a time; if only a partial row is available, it is not returned.
   * Successful return of a data row involves allocating a chunk of memory to hold the data.
   *
   * The buffer parameter must be non-NULL.
   * *buffer is set to point to the allocated memory, or to NULL in cases where no buffer is returned.
   * A non-NULL result buffer should be freed using PQfreemem when no longer needed.
   *
   * When a row is successfully returned, the return value is the number of data bytes in the row (this will always be greater than zero).
   * The returned string is always null-terminated, though this is probably only useful for textual COPY.
   *
   * A result of zero indicates that the COPY is still in progress, but no row is yet available (this is only possible when async is true).
   * When async is true (not zero), PQgetCopyData will not block waiting for input;
   * it will return zero if the COPY is still in progress but no complete row is available.
   * In this case wait for read-ready and then call PQconsumeInput before calling PQgetCopyData again.
   * When async is false (zero), PQgetCopyData will block until data is available or the operation completes.
   *
   * A result of -1 indicates that the COPY is done.
   *
   * A result of -2 indicates that an error occurred (consult PQerrorMessage for the reason).
   *
   * After PQgetCopyData returns -1, call PQgetResult to obtain the final result status of the COPY command.
   * One can wait for this result to be available in the usual way. Then return to normal operation.
   *
   * @return the row length (always > 0) if successful (and sets *buffer to point to a malloc'd row of data), else
   *         0 if no row available yet (only possible if async is true),
   *         -1 if end of copy (consult PQgetResult),
   *         or -2 if error (consult PQerrorMessage).
   */
  def PQgetCopyData(conn: Ptr[PGconn], buffer: Ptr[Ptr[Byte]], async: CInt): CInt = extern

  /**
   * PQgetline - gets a newline-terminated string from the backend.
   *
   * Chiefly here so that applications can use \"COPY <rel> to stdout\" and read the
   * output string. Returns a null-terminated string in s.
   *
   * XXX this routine is now deprecated, because it can't handle binary data. If
   * called during a COPY BINARY we return EOF.
   *
   * RETURNS: EOF if error (eg, invalid arguments are given) 0 if EOL is reached
   */
  //@deprecated def PQgetline(conn: Ptr[PGconn], string: CString, length: CInt): CInt = extern

  /**
   * PQputline -- sends a string to the backend during COPY IN.
   * Returns 0 if OK, EOFif not.
   *
   * This is deprecated primarily because the return convention doesn't allow caller
   * to tell the difference between a hard error and a nonblock-mode send failure.
   */
  //@deprecated def PQputline(conn: Ptr[PGconn], string: CString): CInt = extern

  /**
   * PQgetlineAsync - gets a COPY data row without blocking.
   *
   * This routine is for applications that want to do \"COPY <rel> to stdout\"
   * asynchronously, that is without blocking. Having issued the COPY command and
   * gotten a PGRES_COPY_OUT response, the app should call PQconsumeInput and this
   * routine until the end-of-data signal is detected. Unlike PQgetline, this routine
   * takes responsibility for detecting end-of-data.
   *
   * On each call, PQgetlineAsync will return data if a complete data row is
   * available in libpq's input buffer. Otherwise, no data is returned until the rest
   * of the row arrives.
   *
   * If -1 is returned, the end-of-data signal has been recognized (and removed from
   * libpq's input buffer). The caller *must* next call PQendcopy and then return to
   * normal processing.
   *
   * RETURNS: -1 if the end-of-copy-data marker has been recognized 0 if no data is
   * available >0 the number of bytes returned.
   *
   * The data returned will not extend beyond a data-row boundary. If possible a
   * whole row will be returned at one time. But if the buffer offered by the caller
   * is too small to hold a row sent by the backend, then a partial data row will be
   * returned. In text mode this can be detected by testing whether the last returned
   * byte is '
   * ' or not.
   *
   * The returned data is *not* null-terminated.
   */
  //@deprecated def PQgetlineAsync(conn: Ptr[PGconn], buffer: CString, bufsize: CInt): CInt = extern

  /**
   * PQputnbytes -- like PQputline, but buffer need not be null-terminated.
   * Returns 0 if OK, EOF if not.
   */
  //@deprecated def PQputnbytes(conn: Ptr[PGconn], buffer: CString, nbytes: CInt): CInt = extern

  /**
   * PQendcopy After completing the data transfer portion of a copy in/out, the
   * application must call this routine to finish the command protocol.
   *
   * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult to
   * get the transfer status. Note however that when using 2.0 protocol, recovering
   * from a copy failure often requires a PQreset. PQendcopy will take care of that,
   * PQgetResult won't.
   *
   * RETURNS: 0 on success 1 on failure
   */
  //@deprecated def PQendcopy(conn: Ptr[PGconn]): CInt = extern

  /**
   * PQsetnonblocking: sets the PGconn's database connection non-blocking if the arg
   * is true or makes it blocking if the arg is false, this will not protect you from
   * PQexec(), you'll only be safe when using the non-blocking API. Needs to be
   * called only on a connected database connection.
   *
   * @return zero if successful,
   *         -1 if there is a problem in changing the mode of the connection.
   *
   */
  def PQsetnonblocking(conn: Ptr[PGconn], arg: CInt): CInt = extern

  /**
   * Return the blocking status of the database connection
   *
   * @return true == nonblocking, false == blocking
   */
  def PQisnonblocking(conn: Ptr[PGconn]): CInt = extern

  def PQisthreadsafe(): CInt = extern
  def PQregisterThreadLock(newhandler: CFuncPtr1[CInt, Unit]): CFuncPtr1[CInt, Unit] = extern

  /**
   * PQping reports the status of the server.
   *
   * It accepts connection parameters identical to those of PQconnectdb.
   * It is not necessary to supply correct user name, password, or database name values to obtain the server status.
   * However, if incorrect values are provided, the server will log a failed connection attempt.
   *
   * @return one value of the PGPing enumeration (PQPING_OK, PQPING_REJECT, PQPING_NO_RESPONSE, PQPING_NO_ATTEMPT).
   */
  def PQping(conninfo: CString): PGPing = extern

  /**
   * PQpingParams reports the status of the server.
   *
   * It accepts connection parameters identical to those of PQconnectdbParams.
   * It is not necessary to supply correct user name, password, or database name values to obtain the server status.
   * However, if incorrect values are provided, the server will log a failed connection attempt.
   *
   *  @return one value of the PGPing enumeration (PQPING_OK, PQPING_REJECT, PQPING_NO_RESPONSE, PQPING_NO_ATTEMPT).
   */
  def PQpingParams(keywords: Ptr[CString], values: Ptr[CString], expand_dbname: CInt): PGPing = extern

  /**
   * Attempts to flush any queued output data to the server.
   *
   * Returns 0 if successful (or if the send queue is empty), -1 if it failed for some reason,
   * or 1 if it was unable to send all the data in the send queue yet
   * (this case can only occur if the connection is nonblocking).
   */
  def PQflush(conn: Ptr[PGconn]): CInt = extern

  /**
   *  PQfn - Send a function call to the POSTGRES backend.
   *
   * conn : backend connection fnid : OID of function to be called result_buf :
   * pointer to result buffer result_len : actual length of result is returned here
   * result_is_int : If the result is an integer, this must be 1, otherwise this
   * should be 0 args : pointer to an array of function arguments (each has length,
   * if integer, and value/pointer) nargs : # of arguments in args array.
   *
   * RETURNS PGresult with status = PGRES_COMMAND_OK if successful. *result_len is >
   * 0 if there is a return value, 0 if not. PGresult with status = PGRES_FATAL_ERROR
   * if backend returns an error.
   *
   * NULL on communications failure. conn->errorMessage will be set.
   * ---------------------------------------------------------------
   * clear the error string
   */
  def PQfn(conn: Ptr[PGconn], fnid: CInt, result_buf: Ptr[CInt], result_len: Ptr[CInt], result_is_int: CInt, args: Ptr[PQArgBlock], nargs: CInt): Ptr[PGresult] = extern

  /**
   * Returns the result status of the command.
   *
   * @return a value of the ExecStatusType enumeration
   */
  def PQresultStatus(res: Ptr[PGresult]): ExecStatusType = extern

  /**
   * Converts the enumerated type returned by PQresultStatus into a string constant describing the status code.
   *
   * The caller should not free the result.
   */
  def PQresStatus(status: ExecStatusType): CString = extern

  /**
   * Returns the error message associated with the command, or an empty string if there was no error.
   *
   * If there was an error, the returned string will include a trailing newline.
   * The caller should not free the result directly.
   * It will be freed when the associated PGresult handle is passed to PQclear.
   *
   * Immediately following a PQexec or PQgetResult call, PQerrorMessage (on the connection)
   * will return the same string as PQresultErrorMessage (on the result).
   * However, a PGresult will retain its error message until destroyed,
   * whereas the connection's error message will change when subsequent operations are done.
   * Use PQresultErrorMessage when you want to know the status associated with a particular PGresult.
   * Use PQerrorMessage when you want to know the status from the latest operation on the connection.
   */
  def PQresultErrorMessage(res: Ptr[PGresult]): CString = extern

  /**
   * Because the caller is expected to free the result string, we must strdup any
   * constant result. We use plain strdup and document that callers should expect
   * NULL if out-of-memory.
   *
   * Currently, we pass this off to fe-protocol3.c in all cases; it will behave
   * reasonably sanely with an error reported by fe-protocol2.c as well. If
   * necessary, we could record the protocol version in PGresults so as to be able to
   * invoke a version-specific message formatter, but for now there's no need.
   *
   * If insufficient memory to format the message, fail cleanly
   */
  def PQresultVerboseErrorMessage(res: Ptr[PGresult], verbosity: PGVerbosity, show_context: PGContextVisibility): CString = extern

  /**
   * Returns an individual field of an error report.
   *
   * Field values will normally not include a trailing newline. The caller should not free the result directly.
   * It will be freed when the associated PGresult handle is passed to PQclear.
   *
   * @param res a PGresult pointer
   * @param fieldcode an error field identifier (member of PGErrorFieldIdentifier enum)
   * @return an error message or NULL if the PGresult is not an error or warning result, or does not include the specified field.
   */
  def PQresultErrorField(res: Ptr[PGresult], fieldcode: CInt): CString = extern

  /**
   * Returns the number of rows (tuples) in the query result.
   *
   * Note that PGresult objects are limited to no more than INT_MAX rows, so an int result is sufficient.
   */
  def PQntuples(res: Ptr[PGresult]): CInt = extern

  /**
   * Returns the number of columns (fields) in each row of the query result.
   */
  def PQnfields(res: Ptr[PGresult]): CInt = extern

  /**
   * Returns 1 if the PGresult contains binary data and 0 if it contains text data.
   *
   * This function is deprecated (except for its use in connection with COPY),
   * because it is possible for a single PGresult to contain text data in some columns and binary data in others.
   * PQfformat is preferred.
   *
   * @return 1 only if all columns of the result are binary (format 1), else 0
   */
  def PQbinaryTuples(res: Ptr[PGresult]): CInt = extern

  /**
   * Returns the column name associated with the given column number (starts at 0).
   *
   * The caller should not free the result directly.
   * It will be freed when the associated PGresult handle is passed to PQclear.
   *
   * @return NULL if the column number is out of range.
   */
  def PQfname(res: Ptr[PGresult], field_num: CInt): CString = extern

  /**
   * PQfnumber: finds the column number (starts at zero) associated with the given column name.
   *
   * The column name is treated like an identifier in an SQL command, that is, it is downcased unless double-quoted.
   * But note a possible gotcha: downcasing in the frontend might follow different locale rules than downcasing in the backend...
   *
   * In the present backend it is also possible to have multiple matches, in which case the first one is found.
   *
   * @return -1 if no match, otherwise the found column number
   */
  def PQfnumber(res: Ptr[PGresult], field_name: CString): CInt = extern
  def PQftable(res: Ptr[PGresult], field_num: CInt): Oid = extern
  def PQftablecol(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQfformat(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQftype(res: Ptr[PGresult], field_num: CInt): Oid = extern
  def PQfsize(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQfmod(res: Ptr[PGresult], field_num: CInt): CInt = extern

  /**
   * Returns the command status tag from the SQL command that generated the PGresult.
   *
   * Commonly this is just the name of the command, but it might include additional data such as the number of rows processed.
   * The caller should not free the result directly. It will be freed when the associated PGresult handle is passed to PQclear.
   */
  def PQcmdStatus(res: Ptr[PGresult]): CString = extern

  /**
   * This function is deprecated in favor of PQoidValue and is not thread-safe.
   * It returns a string with the OID of the inserted row, while PQoidValue returns the OID value.
   */
  //@deprecated def PQoidStatus(res: Ptr[PGresult]): CString = extern

  /**
   * Returns the OID of the inserted row.
   *
   * @return a valid OID if the SQL command was an INSERT that inserted exactly one row into a table that has OIDs,
   * or a EXECUTE of a prepared query containing a suitable INSERT statement.
   * Otherwise, this function returns InvalidOid (or if the table affected by the INSERT statement does not contain OIDs).
   */
  def PQoidValue(res: Ptr[PGresult]): Oid = extern

  /**
   * Returns the number of rows affected by the SQL command.
   *
   * This function can only be used following the execution of a SELECT, CREATE TABLE AS, INSERT, UPDATE, DELETE, MOVE, FETCH, or COPY statement,
   * or an EXECUTE of a prepared query that contains an INSERT, UPDATE, or DELETE statement.
   *
   * The caller should not free the return value directly.
   * It will be freed when the associated PGresult handle is passed to PQclear.
   *
   * @return a string containing the number of rows affected by the SQL statement that generated the PGresult,
   *         or an empty string if the kind of command that generated the PGresult is invalid (see above).
   */
  def PQcmdTuples(res: Ptr[PGresult]): CString = extern

  /**
   * PQgetvalue: return the value of field 'field_num' of row 'tup_num'
   */
  def PQgetvalue(res: Ptr[PGresult], tup_num: CInt, field_num: CInt): CString = extern

  /**
   * PQgetlength: returns the actual length of a field value in bytes.
   */
  def PQgetlength(res: Ptr[PGresult], tup_num: CInt, field_num: CInt): CInt = extern

  /**
   * PQgetisnull: returns the null status of a field value.
   *
   * Row and column numbers start at 0.
   * Note that PQgetvalue will return an empty string, not a null pointer, for a null field.
   *
   * @return 1 if the field is null and 0 if it contains a non-null value.
   */
  def PQgetisnull(res: Ptr[PGresult], tup_num: CInt, field_num: CInt): CInt = extern

  /**
   * PQnparams: returns the number of input parameters of a prepared statement.
   */
  def PQnparams(res: Ptr[PGresult]): CInt = extern

  /**
   * PQparamtype: returns type Oid of the specified statement parameter.
   */
  def PQparamtype(res: Ptr[PGresult], param_num: CInt): Oid = extern

  /**
   * PQdescribePrepared Obtain information about a previously prepared statement
   *
   * If the query was not even sent, return NULL; conn->errorMessage is set to a
   * relevant message. If the query was sent, a new PGresult is returned (which could
   * indicate either success or failure). On success, the PGresult contains status
   * PGRES_COMMAND_OK, and its parameter and column-heading fields describe the
   * statement's inputs and outputs respectively. The user is responsible for freeing
   * the PGresult via PQclear() when done with it.
   */
  def PQdescribePrepared(conn: Ptr[PGconn], stmt: CString): Ptr[PGresult] = extern

  /**
   * PQdescribePortal Obtain information about a previously created portal
   *
   * This is much like PQdescribePrepared, except that no parameter info is returned.
   * Note that at the moment, libpq doesn't really expose portals to the client; but
   * this can be used with a portal created by a SQL DECLARE CURSOR command.
   */
  def PQdescribePortal(conn: Ptr[PGconn], portal: CString): Ptr[PGresult] = extern

  /**
   * PQsendDescribePrepared Submit a Describe Statement command, but don't wait for
   * it to finish
   *
   * Returns: 1 if successfully submitted 0 if error (conn->errorMessage is set)
   */
  def PQsendDescribePrepared(conn: Ptr[PGconn], stmt: CString): CInt = extern

  /**
   * PQsendDescribePortal Submit a Describe Portal command, but don't wait for it to
   * finish
   *
   * Returns: 1 if successfully submitted 0 if error (conn->errorMessage is set)
   */
  def PQsendDescribePortal(conn: Ptr[PGconn], portal: CString): CInt = extern

  /**
   * PQclear - free's the memory associated with a PGresult
   *
   * only send DESTROY to successfully-initialized event procs
   *
   * Free all the subsidiary blocks
   *
   * Free the top-level tuple pointer array
   *
   * zero out the pointer fields to catch programming errors
   *
   * res->curBlock was zeroed out earlier
   *
   * Free the PGresult structure itself
   */
  def PQclear(res: Ptr[PGresult]): Unit = extern

  /**
   * PQfreemem - safely frees memory allocated
   *
   * Needed mostly by Win32, unless multithreaded DLL (/MD in VC6) Used for freeing
   * memory from PQescapeBytea()/PQunescapeBytea()
   */
  def PQfreemem(ptr: Ptr[Byte]): Unit = extern

  /**
   * PQmakeEmptyPGresult returns a newly allocated, initialized PGresult with given
   * status. If conn is not NULL and status indicates an error, the conn's
   * errorMessage is copied. Also, any PGEvents are copied from the conn.
   *
   * copy connection data we might need for operations on PGresult
   *
   * consider copying conn's errorMessage
   *
   * non-error cases
   *
   * copy events last; result must be valid if we need to PQclear
   *
   * defaults...
   */
  def PQmakeEmptyPGresult(conn: Ptr[PGconn], status: ExecStatusType): Ptr[PGresult] = extern

  /**
   * PQcopyResult
   *
   * Returns a deep copy of the provided 'src' PGresult, which cannot be NULL. The
   * 'flags' argument controls which portions of the result will or will NOT be
   * copied. The created result is always put into the PGRES_TUPLES_OK status. The
   * source result error message is not copied, although cmdStatus is.
   *
   * To set custom attributes, use PQsetResultAttrs. That function requires that
   * there are no attrs contained in the result, so to use that function you cannot
   * use the PG_COPYRES_ATTRS or PG_COPYRES_TUPLES options with this function.
   *
   * Options: PG_COPYRES_ATTRS - Copy the source result's attributes
   *
   * PG_COPYRES_TUPLES - Copy the source result's tuples. This implies copying the
   * attrs, seeing how the attrs are needed by the tuples.
   *
   * PG_COPYRES_EVENTS - Copy the source result's events.
   *
   * PG_COPYRES_NOTICEHOOKS - Copy the source result's notice hooks.
   *
   * Always copy these over. Is cmdStatus really useful here?
   *
   * Wants attrs?
   *
   * Wants to copy tuples?
   *
   * Wants to copy notice hooks?
   *
   * Wants to copy PGEvents?
   *
   * Okay, trigger PGEVT_RESULTCOPY event
   */
  def PQcopyResult(src: Ptr[PGresult], flags: CInt): Ptr[PGresult] = extern

  /**
   * PQsetResultAttrs
   *
   * Set the attributes for a given result. This function fails if there are already
   * attributes contained in the provided result. The call is ignored if
   * numAttributes is zero or attDescs is NULL. If the function fails, it returns
   * zero. If the function succeeds, it returns a non-zero value.
   *
   * If attrs already exist, they cannot be overwritten.
   *
   * ignore no-op request
   *
   * deep-copy the attribute names, and determine format
   */
  def PQsetResultAttrs(res: Ptr[PGresult], numAttributes: CInt, attDescs: Ptr[PGresAttDesc]): CInt = extern

  /**
   * pqResultAlloc - exported routine to allocate local storage in a PGresult.
   *
   * We force all such allocations to be maxaligned, since we don't know whether the
   * value might be binary.
   */
  def PQresultAlloc(res: Ptr[PGresult], nBytes: CSize): Ptr[Byte] = extern

  /**
   * Sets the value for a tuple field. The tup_num must be less than or equal to
   * PQntuples(res). If it is equal, a new tuple is created and added to the result.
   * Returns a non-zero value for success and zero for failure. (On failure, we
   * report the specific problem via pqInternalNotice.)
   *
   * Note that this check also protects us against null \"res\"
   *
   * Invalid tup_num, must be <= ntups
   *
   * need to allocate a new tuple?
   *
   * initialize each column to NULL
   *
   * add it to the array
   *
   * treat either NULL_LEN or NULL value pointer as a NULL field
   *
   * Report failure via pqInternalNotice. If preceding code didn't provide an error
   * message, assume \"out of memory\" was meant.
   */
  def PQsetvalue(res: Ptr[PGresult], tup_num: CInt, field_num: CInt, value: CString, len: CInt): CInt = extern

  /**
   * force empty-string result
   */
  def PQescapeStringConn(conn: Ptr[PGconn], to: CString, from: CString, length: CSize, error: Ptr[CInt]): CSize = extern
  def PQescapeLiteral(conn: Ptr[PGconn], str: CString, len: CSize): CString = extern
  def PQescapeIdentifier(conn: Ptr[PGconn], str: CString, len: CSize): CString = extern
  def PQescapeByteaConn(conn: Ptr[PGconn], from: Ptr[CUnsignedChar], from_length: CSize, to_length: Ptr[CSize]): Ptr[CUnsignedChar] = extern

  /**
   * PQunescapeBytea - converts the null terminated string representation of a bytea,
   * strtext, into binary, filling a buffer. It returns a pointer to the buffer (or
   * NULL on error), and the size of the buffer in retbuflen. The pointer may
   * subsequently be used as an argument to the function PQfreemem.
   *
   * The following transformations are made: \\ == ASCII 92 == \\  == a byte whose
   * value = ooo (ooo is an octal number)  == x (x is any character not matched by
   * the above transformations)
   *
   * Avoid unportable malloc(0)
   *
   * Bad input is silently ignored. Note that this includes whitespace between hex
   * pairs, which is allowed by byteain.
   *
   * Length of input is max length of output, but add one to avoid unportable
   * malloc(0) if input is zero-length.
   *
   * Note: if we see '\\' followed by something that isn't a recognized escape
   * sequence, we loop around having done nothing except advance i. Therefore the
   * something will be emitted as ordinary data on the next cycle. Corner case: '\\'
   * at end of string will just be discarded.
   *
   * buflen is the length of the dequoted data
   *
   * Shrink the buffer to be no larger than necessary
   *
   * +1 avoids unportable behavior when buflen==0
   *
   * It would only be a very brain-dead realloc that could fail, but...
   */
  def PQunescapeBytea(strtext: Ptr[CUnsignedChar], retbuflen: Ptr[CSize]): Ptr[CUnsignedChar] = extern
  def PQescapeString(to: CString, from: CString, length: CSize): CSize = extern

  /**
   * can't use hex
   */
  def PQescapeBytea(from: Ptr[CUnsignedChar], from_length: CSize, to_length: Ptr[CSize]): Ptr[CUnsignedChar] = extern

  /**
   * PQprint()
   *
   * Format results of a query for printing.
   *
   * PQprintOpt is a typedef (structure) that contains various flags and options.
   * consult libpq-fe.h for details
   *
   * This function should probably be removed sometime since psql doesn't use it
   * anymore. It is unclear to what extent this is used by external clients, however.
   *
   * only print rows with at least 1 field.
   *
   * in case we don't use them
   *
   * If we think there'll be more than one screen of output, try to pipe to the pager
   * program.
   *
   * Since this function is no longer used by psql, we don't examine PSQL_PAGER. It's
   * possible that the hypothetical external users of the function would like that to
   * happen, but in the name of backwards compatibility, we'll stick to just
   * examining PAGER.
   *
   * if PAGER is unset, empty or all-white-space, don't use pager
   *
   * row count and newline
   *
   * ENABLE_THREAD_SAFETY
   *
   * WIN32
   *
   * ENABLE_THREAD_SAFETY
   *
   * WIN32
   */
  def PQprint(fout: Ptr[FILE], res: Ptr[PGresult], ps: Ptr[PQprintOpt]): Unit = extern

  /**
   * really old printing routines
   *
   * Get some useful info about the results
   *
   * Figure the field lengths to align to
   *
   * will be somewhat time consuming for very large results
   *
   * first, print out the attribute names
   *
   * Underline the attribute names
   *
   * next, print out the instances
   */
  def PQdisplayTuples(res: Ptr[PGresult], fp: Ptr[FILE], fillAlign: CInt, fieldSep: CString, printHeader: CInt, quiet: CInt): Unit = extern

  /**
   * only print rows with at least 1 field.
   */
  def PQprintTuples(res: Ptr[PGresult], fout: Ptr[FILE], printAttName: CInt, terseOutput: CInt, width: CInt): Unit = extern

  /**
   * lo_open opens an existing large object
   *
   * returns the file descriptor for use in later lo_* calls return -1 upon failure.
   */
  def lo_open(conn: Ptr[PGconn], lobjId: Oid, mode: CInt): CInt = extern

  /**
   * lo_close closes an existing large object
   *
   * returns 0 upon success returns -1 upon failure.
   */
  def lo_close(conn: Ptr[PGconn], fd: CInt): CInt = extern

  /**
   * lo_read read len bytes of the large object into buf
   *
   * returns the number of bytes read, or -1 on failure. the CALLER must have
   * allocated enough space to hold the result returned
   *
   * Long ago, somebody thought it'd be a good idea to declare this function as
   * taking size_t ... but the underlying backend function only accepts a signed
   * int32 length. So throw error if the given value overflows int32.
   */
  def lo_read(conn: Ptr[PGconn], fd: CInt, buf: CString, len: CSize): CInt = extern

  /**
   * lo_write write len bytes of buf into the large object fd
   *
   * returns the number of bytes written, or -1 on failure.
   *
   * Long ago, somebody thought it'd be a good idea to declare this function as
   * taking size_t ... but the underlying backend function only accepts a signed
   * int32 length. So throw error if the given value overflows int32.
   */
  def lo_write(conn: Ptr[PGconn], fd: CInt, buf: CString, len: CSize): CInt = extern

  /**
   * lo_lseek change the current read or write location on a large object
   */
  def lo_lseek(conn: Ptr[PGconn], fd: CInt, offset: CInt, whence: CInt): CInt = extern

  /**
   * lo_lseek64 change the current read or write location on a large object
   */
  def lo_lseek64(conn: Ptr[PGconn], fd: CInt, offset: pg_int64, whence: CInt): pg_int64 = extern

  /**
   * lo_creat create a new large object the mode is ignored (once upon a time it had
   * a use)
   *
   * returns the oid of the large object created or InvalidOid upon failure
   */
  def lo_creat(conn: Ptr[PGconn], mode: CInt): Oid = extern

  /**
   * lo_create create a new large object if lobjId isn't InvalidOid, it specifies the
   * OID to (attempt to) create
   *
   * returns the oid of the large object created or InvalidOid upon failure
   *
   * Must check this on-the-fly because it's not there pre-8.1
   */
  def lo_create(conn: Ptr[PGconn], lobjId: Oid): Oid = extern

  /**
   * lo_tell returns the current seek location of the large object
   */
  def lo_tell(conn: Ptr[PGconn], fd: CInt): CInt = extern

  /**
   * lo_tell64 returns the current seek location of the large object
   */
  def lo_tell64(conn: Ptr[PGconn], fd: CInt): pg_int64 = extern

  /**
   * lo_truncate truncates an existing large object to the given size
   *
   * returns 0 upon success returns -1 upon failure
   *
   * Must check this on-the-fly because it's not there pre-8.3
   *
   * Long ago, somebody thought it'd be a good idea to declare this function as
   * taking size_t ... but the underlying backend function only accepts a signed
   * int32 length. So throw error if the given value overflows int32. (A possible
   * alternative is to automatically redirect the call to lo_truncate64; but if the
   * caller wanted to rely on that backend function being available, he could have
   * called lo_truncate64 for himself.)
   */
  def lo_truncate(conn: Ptr[PGconn], fd: CInt, len: CSize): CInt = extern

  /**
   * lo_truncate64 truncates an existing large object to the given size
   *
   * returns 0 upon success returns -1 upon failure
   */
  def lo_truncate64(conn: Ptr[PGconn], fd: CInt, len: pg_int64): CInt = extern

  /**
   * lo_unlink delete a file
   */
  def lo_unlink(conn: Ptr[PGconn], lobjId: Oid): CInt = extern

  /**
   * lo_import - imports a file as an (inversion) large object.
   *
   * returns the oid of that object upon success, returns InvalidOid upon failure
   */
  def lo_import(conn: Ptr[PGconn], filename: CString): Oid = extern

  /**
   * lo_import_with_oid - imports a file as an (inversion) large object. large object
   * id can be specified.
   *
   * returns the oid of that object upon success, returns InvalidOid upon failure
   */
  def lo_import_with_oid(conn: Ptr[PGconn], filename: CString, lobjId: Oid): Oid = extern

  /**
   * lo_export - exports an (inversion) large object. returns -1 upon failure, 1 if
   * OK
   *
   * open the large object.
   *
   * we assume lo_open() already set a suitable error message
   *
   * create the file to be written to
   *
   * We must do lo_close before setting the errorMessage
   *
   * read in from the large object and write to the file
   *
   * We must do lo_close before setting the errorMessage
   *
   * If lo_read() failed, we are now in an aborted transaction so there's no need for
   * lo_close(); furthermore, if we tried it we'd overwrite the useful error result
   * with a useless one. So skip lo_close() if we got a failure result.
   *
   * assume lo_read() or lo_close() left a suitable error message
   *
   * if we already failed, don't overwrite that msg with a close error
   */
  def lo_export(conn: Ptr[PGconn], lobjId: Oid, filename: CString): CInt = extern

  /**
   * A couple of \"miscellaneous\" multibyte related functions. They used to be in
   * fe-print.c but that file is doomed. returns the byte length of the character
   * beginning at s, using the specified encoding.
   */
  def PQmblen(s: CString, encoding: CInt): CInt = extern

  /**
   * returns the display length of the character beginning at s, using the specified
   * encoding.
   */
  def PQdsplen(s: CString, encoding: CInt): CInt = extern
  def PQenv2encoding(): CInt = extern

  /**
   * PQencryptPassword -- exported routine to encrypt a password with MD5
   *
   * This function is equivalent to calling PQencryptPasswordConn with \"md5\" as the
   * encryption method, except that this doesn't require a connection object. This
   * function is deprecated, use PQencryptPasswordConn instead.
   */
  def PQencryptPassword(passwd: CString, user: CString): CString = extern

  /**
   * PQencryptPasswordConn -- exported routine to encrypt a password
   *
   * This is intended to be used by client applications that wish to send commands
   * like ALTER USER joe PASSWORD 'pwd'. The password need not be sent in cleartext
   * if it is encrypted on the client side. This is good because it ensures the
   * cleartext password won't end up in logs, pg_stat displays, etc. We export the
   * function so that clients won't be dependent on low-level details like whether
   * the encryption is MD5 or something else.
   *
   * Arguments are a connection object, the cleartext password, the SQL name of the
   * user it is for, and a string indicating the algorithm to use for encrypting the
   * password. If algorithm is NULL, this queries the server for the current
   * 'password_encryption' value. If you wish to avoid that, e.g. to avoid blocking,
   * you can execute 'show password_encryption' yourself before calling this
   * function, and pass it as the algorithm.
   *
   * Return value is a malloc'd string. The client may assume the string doesn't
   * contain any special characters that would require escaping. On error, an error
   * message is stored in the connection object, and returns NULL.
   *
   * If no algorithm was given, ask the server.
   *
   * PQexec() should've set conn->errorMessage already
   *
   * PQexec() should've set conn->errorMessage already
   *
   * Also accept \"on\" and \"off\" as aliases for \"md5\", because
   * password_encryption was a boolean before PostgreSQL 10. We refuse to send the
   * password in plaintext even if it was \"off\".
   *
   * Ok, now we know what algorithm to use
   */
  def PQencryptPasswordConn(conn: Ptr[PGconn], passwd: CString, user: CString, algorithm: CString): CString = extern

  /**
   * Search encoding by encoding name.
   *
   * Returns encoding ID, or -1 for error.
   */
  def pg_char_to_encoding(name: CString): CInt = extern

  /**
   * Search encoding name by encoding ID.
   *
   * Returns encoding name, or "" if invalid encoding ID.
   */
  def pg_encoding_to_char(encoding: CInt): CString = extern

  /** Client encoding check, for error returns -1 else encoding id */
  //def pg_valid_client_encoding(encoding: CString): CInt = extern // ADDED BY DBO
  /** Server encoding check, for error returns -1 else encoding id */
  //def pg_valid_server_encoding(encoding: CString): CInt = extern // ADDED BY DBO
  /** Server encoding ID check, for error returns -1 else encoding id */
  //def pg_valid_server_encoding_id(encoding: CInt): CInt = extern // COMMENTED BY DBO



  /*
  def PQconnectStart(conninfo: CString): Ptr[PGconn] = extern
  def PQconnectStartParams(keywords: Ptr[CString], values: Ptr[CString], expand_dbname: CInt): Ptr[PGconn] = extern
  def PQconnectPoll(conn: Ptr[PGconn]): PostgresPollingStatusType = extern
  def PQconnectdb(conninfo: CString): Ptr[PGconn] = extern
  def PQconnectdbParams(keywords: Ptr[CString], values: Ptr[CString], expand_dbname: CInt): Ptr[PGconn] = extern
  def PQsetdbLogin(pghost: CString, pgport: CString, pgoptions: CString, pgtty: CString, dbName: CString, login: CString, pwd: CString): Ptr[PGconn] = extern
  def PQfinish(conn: Ptr[PGconn]): Unit = extern
  def PQconndefaults(): Ptr[PQconninfoOption] = extern
  def PQconninfoParse(conninfo: CString, errmsg: Ptr[CString]): Ptr[PQconninfoOption] = extern
  def PQconninfo(conn: Ptr[PGconn]): Ptr[PQconninfoOption] = extern
  def PQconninfoFree(connOptions: Ptr[PQconninfoOption]): Unit = extern
  def PQresetStart(conn: Ptr[PGconn]): CInt = extern
  def PQresetPoll(conn: Ptr[PGconn]): PostgresPollingStatusType = extern
  def PQreset(conn: Ptr[PGconn]): Unit = extern
  def PQgetCancel(conn: Ptr[PGconn]): Ptr[PGcancel] = extern
  def PQfreeCancel(cancel: Ptr[PGcancel]): Unit = extern
  def PQcancel(cancel: Ptr[PGcancel], errbuf: CString, errbufsize: CInt): CInt = extern
  def PQrequestCancel(conn: Ptr[PGconn]): CInt = extern
  def PQdb(conn: Ptr[PGconn]): CString = extern
  def PQuser(conn: Ptr[PGconn]): CString = extern
  def PQpass(conn: Ptr[PGconn]): CString = extern
  def PQhost(conn: Ptr[PGconn]): CString = extern
  def PQport(conn: Ptr[PGconn]): CString = extern
  def PQtty(conn: Ptr[PGconn]): CString = extern
  def PQoptions(conn: Ptr[PGconn]): CString = extern
  def PQstatus(conn: Ptr[PGconn]): ConnStatusType = extern
  def PQtransactionStatus(conn: Ptr[PGconn]): PGTransactionStatusType = extern
  def PQparameterStatus(conn: Ptr[PGconn], paramName: CString): CString = extern
  def PQprotocolVersion(conn: Ptr[PGconn]): CInt = extern
  def PQserverVersion(conn: Ptr[PGconn]): CInt = extern
  def PQerrorMessage(conn: Ptr[PGconn]): CString = extern
  def PQsocket(conn: Ptr[PGconn]): CInt = extern
  def PQbackendPID(conn: Ptr[PGconn]): CInt = extern
  def PQconnectionNeedsPassword(conn: Ptr[PGconn]): CInt = extern
  def PQconnectionUsedPassword(conn: Ptr[PGconn]): CInt = extern
  def PQclientEncoding(conn: Ptr[PGconn]): CInt = extern
  def PQsetClientEncoding(conn: Ptr[PGconn], encoding: CString): CInt = extern
  def PQsslInUse(conn: Ptr[PGconn]): CInt = extern
  def PQsslStruct(conn: Ptr[PGconn], struct_name: CString): Ptr[Byte] = extern
  def PQsslAttribute(conn: Ptr[PGconn], attribute_name: CString): CString = extern
  def PQsslAttributeNames(conn: Ptr[PGconn]): Ptr[CString] = extern
  def PQgetssl(conn: Ptr[PGconn]): Ptr[Byte] = extern
  def PQinitSSL(do_init: CInt): Unit = extern
  def PQinitOpenSSL(do_ssl: CInt, do_crypto: CInt): Unit = extern
  def PQsetErrorVerbosity(conn: Ptr[PGconn], verbosity: PGVerbosity): PGVerbosity = extern
  def PQsetErrorContextVisibility(conn: Ptr[PGconn], show_context: PGContextVisibility): PGContextVisibility = extern
  def PQtrace(conn: Ptr[PGconn], debug_port: Ptr[FILE]): Unit = extern
  def PQuntrace(conn: Ptr[PGconn]): Unit = extern
  def PQsetNoticeReceiver(conn: Ptr[PGconn], proc: CFuncPtr2[Ptr[Byte], Ptr[PGresult], Unit], arg: Ptr[Byte]): CFuncPtr2[Ptr[Byte], Ptr[PGresult], Unit] = extern
  def PQsetNoticeProcessor(conn: Ptr[PGconn], proc: CFuncPtr2[Ptr[Byte], CString, Unit], arg: Ptr[Byte]): CFuncPtr2[Ptr[Byte], CString, Unit] = extern
  def PQregisterThreadLock(newhandler: CFuncPtr1[CInt, Unit]): CFuncPtr1[CInt, Unit] = extern
  def PQexec(conn: Ptr[PGconn], query: CString): Ptr[PGresult] = extern
  def PQexecParams(conn: Ptr[PGconn], command: CString, nParams: CInt, paramTypes: Ptr[Oid], paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): Ptr[PGresult] = extern
  def PQprepare(conn: Ptr[PGconn], stmtName: CString, query: CString, nParams: CInt, paramTypes: Ptr[Oid]): Ptr[PGresult] = extern
  def PQexecPrepared(conn: Ptr[PGconn], stmtName: CString, nParams: CInt, paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): Ptr[PGresult] = extern
  def PQsendQuery(conn: Ptr[PGconn], query: CString): CInt = extern
  def PQsendQueryParams(conn: Ptr[PGconn], command: CString, nParams: CInt, paramTypes: Ptr[Oid], paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): CInt = extern
  def PQsendPrepare(conn: Ptr[PGconn], stmtName: CString, query: CString, nParams: CInt, paramTypes: Ptr[Oid]): CInt = extern
  def PQsendQueryPrepared(conn: Ptr[PGconn], stmtName: CString, nParams: CInt, paramValues: Ptr[CString], paramLengths: Ptr[CInt], paramFormats: Ptr[CInt], resultFormat: CInt): CInt = extern
  def PQsetSingleRowMode(conn: Ptr[PGconn]): CInt = extern
  def PQgetResult(conn: Ptr[PGconn]): Ptr[PGresult] = extern
  def PQisBusy(conn: Ptr[PGconn]): CInt = extern
  def PQconsumeInput(conn: Ptr[PGconn]): CInt = extern
  def PQnotifies(conn: Ptr[PGconn]): Ptr[PGnotify] = extern
  def PQputCopyData(conn: Ptr[PGconn], buffer: CString, nbytes: CInt): CInt = extern
  def PQputCopyEnd(conn: Ptr[PGconn], errormsg: CString): CInt = extern
  def PQgetCopyData(conn: Ptr[PGconn], buffer: Ptr[CString], async: CInt): CInt = extern
  def PQgetline(conn: Ptr[PGconn], string: CString, length: CInt): CInt = extern
  def PQputline(conn: Ptr[PGconn], string: CString): CInt = extern
  def PQgetlineAsync(conn: Ptr[PGconn], buffer: CString, bufsize: CInt): CInt = extern
  def PQputnbytes(conn: Ptr[PGconn], buffer: CString, nbytes: CInt): CInt = extern
  def PQendcopy(conn: Ptr[PGconn]): CInt = extern
  def PQsetnonblocking(conn: Ptr[PGconn], arg: CInt): CInt = extern
  def PQisnonblocking(conn: Ptr[PGconn]): CInt = extern
  def PQisthreadsafe(): CInt = extern
  def PQping(conninfo: CString): PGPing = extern
  def PQpingParams(keywords: Ptr[CString], values: Ptr[CString], expand_dbname: CInt): PGPing = extern
  def PQflush(conn: Ptr[PGconn]): CInt = extern
  def PQfn(conn: Ptr[PGconn], fnid: CInt, result_buf: Ptr[CInt], result_len: Ptr[CInt], result_is_int: CInt, args: Ptr[PQArgBlock], nargs: CInt): Ptr[PGresult] = extern
  def PQresultStatus(res: Ptr[PGresult]): ExecStatusType = extern
  def PQresStatus(status: ExecStatusType): CString = extern
  def PQresultErrorMessage(res: Ptr[PGresult]): CString = extern
  def PQresultVerboseErrorMessage(res: Ptr[PGresult], verbosity: PGVerbosity, show_context: PGContextVisibility): CString = extern
  def PQresultErrorField(res: Ptr[PGresult], fieldcode: CInt): CString = extern
  def PQntuples(res: Ptr[PGresult]): CInt = extern
  def PQnfields(res: Ptr[PGresult]): CInt = extern
  def PQbinaryTuples(res: Ptr[PGresult]): CInt = extern
  def PQfname(res: Ptr[PGresult], field_num: CInt): CString = extern
  def PQfnumber(res: Ptr[PGresult], field_name: CString): CInt = extern
  def PQftable(res: Ptr[PGresult], field_num: CInt): Oid = extern
  def PQftablecol(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQfformat(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQftype(res: Ptr[PGresult], field_num: CInt): Oid = extern
  def PQfsize(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQfmod(res: Ptr[PGresult], field_num: CInt): CInt = extern
  def PQcmdStatus(res: Ptr[PGresult]): CString = extern
  def PQoidStatus(res: Ptr[PGresult]): CString = extern
  def PQoidValue(res: Ptr[PGresult]): Oid = extern
  def PQcmdTuples(res: Ptr[PGresult]): CString = extern
  def PQgetvalue(res: Ptr[PGresult], tup_num: CInt, field_num: CInt): CString = extern
  def PQgetlength(res: Ptr[PGresult], tup_num: CInt, field_num: CInt): CInt = extern
  def PQgetisnull(res: Ptr[PGresult], tup_num: CInt, field_num: CInt): CInt = extern
  def PQnparams(res: Ptr[PGresult]): CInt = extern
  def PQparamtype(res: Ptr[PGresult], param_num: CInt): Oid = extern
  def PQdescribePrepared(conn: Ptr[PGconn], stmt: CString): Ptr[PGresult] = extern
  def PQdescribePortal(conn: Ptr[PGconn], portal: CString): Ptr[PGresult] = extern
  def PQsendDescribePrepared(conn: Ptr[PGconn], stmt: CString): CInt = extern
  def PQsendDescribePortal(conn: Ptr[PGconn], portal: CString): CInt = extern
  def PQclear(res: Ptr[PGresult]): Unit = extern
  def PQfreemem(ptr: Ptr[Byte]): Unit = extern
  def PQmakeEmptyPGresult(conn: Ptr[PGconn], status: ExecStatusType): Ptr[PGresult] = extern
  def PQcopyResult(src: Ptr[PGresult], flags: CInt): Ptr[PGresult] = extern
  def PQsetResultAttrs(res: Ptr[PGresult], numAttributes: CInt, attDescs: Ptr[PGresAttDesc]): CInt = extern
  def PQresultAlloc(res: Ptr[PGresult], nBytes: CSize): Ptr[Byte] = extern
  def PQsetvalue(res: Ptr[PGresult], tup_num: CInt, field_num: CInt, value: CString, len: CInt): CInt = extern
  def PQescapeStringConn(conn: Ptr[PGconn], to: CString, from: CString, length: CSize, error: Ptr[CInt]): CSize = extern
  def PQescapeLiteral(conn: Ptr[PGconn], str: CString, len: CSize): CString = extern
  def PQescapeIdentifier(conn: Ptr[PGconn], str: CString, len: CSize): CString = extern
  def PQescapeByteaConn(conn: Ptr[PGconn], from: Ptr[CUnsignedChar], from_length: CSize, to_length: Ptr[CSize]): Ptr[CUnsignedChar] = extern
  def PQunescapeBytea(strtext: Ptr[CUnsignedChar], retbuflen: Ptr[CSize]): Ptr[CUnsignedChar] = extern
  def PQescapeString(to: CString, from: CString, length: CSize): CSize = extern
  def PQescapeBytea(from: Ptr[CUnsignedChar], from_length: CSize, to_length: Ptr[CSize]): Ptr[CUnsignedChar] = extern
  def PQprint(fout: Ptr[FILE], res: Ptr[PGresult], ps: Ptr[PQprintOpt]): Unit = extern
  def PQdisplayTuples(res: Ptr[PGresult], fp: Ptr[FILE], fillAlign: CInt, fieldSep: CString, printHeader: CInt, quiet: CInt): Unit = extern
  def PQprintTuples(res: Ptr[PGresult], fout: Ptr[FILE], printAttName: CInt, terseOutput: CInt, width: CInt): Unit = extern
  def lo_open(conn: Ptr[PGconn], lobjId: Oid, mode: CInt): CInt = extern
  def lo_close(conn: Ptr[PGconn], fd: CInt): CInt = extern
  def lo_read(conn: Ptr[PGconn], fd: CInt, buf: CString, len: CSize): CInt = extern
  def lo_write(conn: Ptr[PGconn], fd: CInt, buf: CString, len: CSize): CInt = extern
  def lo_lseek(conn: Ptr[PGconn], fd: CInt, offset: CInt, whence: CInt): CInt = extern
  def lo_lseek64(conn: Ptr[PGconn], fd: CInt, offset: pg_int64, whence: CInt): pg_int64 = extern
  def lo_creat(conn: Ptr[PGconn], mode: CInt): Oid = extern
  def lo_create(conn: Ptr[PGconn], lobjId: Oid): Oid = extern
  def lo_tell(conn: Ptr[PGconn], fd: CInt): CInt = extern
  def lo_tell64(conn: Ptr[PGconn], fd: CInt): pg_int64 = extern
  def lo_truncate(conn: Ptr[PGconn], fd: CInt, len: CSize): CInt = extern
  def lo_truncate64(conn: Ptr[PGconn], fd: CInt, len: pg_int64): CInt = extern
  def lo_unlink(conn: Ptr[PGconn], lobjId: Oid): CInt = extern
  def lo_import(conn: Ptr[PGconn], filename: CString): Oid = extern
  def lo_import_with_oid(conn: Ptr[PGconn], filename: CString, lobjId: Oid): Oid = extern
  def lo_export(conn: Ptr[PGconn], lobjId: Oid, filename: CString): CInt = extern
  def PQlibVersion(): CInt = extern
  def PQmblen(s: CString, encoding: CInt): CInt = extern
  def PQdsplen(s: CString, encoding: CInt): CInt = extern
  def PQenv2encoding(): CInt = extern
  @deprecated("use PQencryptPasswordConn instead",since="0.0.1") def PQencryptPassword(passwd: CString, user: CString): CString = extern
  def PQencryptPasswordConn(conn: Ptr[PGconn], passwd: CString, user: CString, algorithm: CString): CString = extern
  def pg_char_to_encoding(name: CString): CInt = extern
  def pg_encoding_to_char(encoding: CInt): CString = extern
  def pg_valid_server_encoding_id(encoding: CInt): CInt = extern
  */

  /*
  object implicits {
    implicit class struct__IO_marker_ops(val p: Ptr[struct__IO_marker]) extends AnyVal {
      def _next: Ptr[struct__IO_marker] = (!p._1).cast[Ptr[struct__IO_marker]]
      def _next_=(value: Ptr[struct__IO_marker]): Unit = !p._1 = value.cast[Ptr[Byte]]
      def _sbuf: Ptr[struct__IO_FILE] = (!p._2).cast[Ptr[struct__IO_FILE]]
      def _sbuf_=(value: Ptr[struct__IO_FILE]): Unit = !p._2 = value.cast[Ptr[Byte]]
      def _pos: CInt = !p._3
      def _pos_=(value: CInt): Unit = !p._3 = value
    }

    implicit class struct__IO_FILE_ops(val p: Ptr[struct__IO_FILE]) extends AnyVal {
      def _flags: CInt = !p._1.cast[Ptr[CInt]]
      def _flags_=(value: CInt): Unit = !p._1.cast[Ptr[CInt]] = value
      def _IO_read_ptr: CString = !(p._1 + 8).cast[Ptr[CString]]
      def _IO_read_ptr_=(value: CString): Unit = !(p._1 + 8).cast[Ptr[CString]] = value
      def _IO_read_end: CString = !(p._1 + 16).cast[Ptr[CString]]
      def _IO_read_end_=(value: CString): Unit = !(p._1 + 16).cast[Ptr[CString]] = value
      def _IO_read_base: CString = !(p._1 + 24).cast[Ptr[CString]]
      def _IO_read_base_=(value: CString): Unit = !(p._1 + 24).cast[Ptr[CString]] = value
      def _IO_write_base: CString = !(p._1 + 32).cast[Ptr[CString]]
      def _IO_write_base_=(value: CString): Unit = !(p._1 + 32).cast[Ptr[CString]] = value
      def _IO_write_ptr: CString = !(p._1 + 40).cast[Ptr[CString]]
      def _IO_write_ptr_=(value: CString): Unit = !(p._1 + 40).cast[Ptr[CString]] = value
      def _IO_write_end: CString = !(p._1 + 48).cast[Ptr[CString]]
      def _IO_write_end_=(value: CString): Unit = !(p._1 + 48).cast[Ptr[CString]] = value
      def _IO_buf_base: CString = !(p._1 + 56).cast[Ptr[CString]]
      def _IO_buf_base_=(value: CString): Unit = !(p._1 + 56).cast[Ptr[CString]] = value
      def _IO_buf_end: CString = !(p._1 + 64).cast[Ptr[CString]]
      def _IO_buf_end_=(value: CString): Unit = !(p._1 + 64).cast[Ptr[CString]] = value
      def _IO_save_base: CString = !(p._1 + 72).cast[Ptr[CString]]
      def _IO_save_base_=(value: CString): Unit = !(p._1 + 72).cast[Ptr[CString]] = value
      def _IO_backup_base: CString = !(p._1 + 80).cast[Ptr[CString]]
      def _IO_backup_base_=(value: CString): Unit = !(p._1 + 80).cast[Ptr[CString]] = value
      def _IO_save_end: CString = !(p._1 + 88).cast[Ptr[CString]]
      def _IO_save_end_=(value: CString): Unit = !(p._1 + 88).cast[Ptr[CString]] = value
      def _markers: Ptr[struct__IO_marker] = !(p._1 + 96).cast[Ptr[Ptr[struct__IO_marker]]]
      def _markers_=(value: Ptr[struct__IO_marker]): Unit = !(p._1 + 96).cast[Ptr[Ptr[struct__IO_marker]]] = value
      def _chain: Ptr[struct__IO_FILE] = (!(p._1 + 104).cast[Ptr[Ptr[struct__IO_FILE]]]).cast[Ptr[struct__IO_FILE]]
      def _chain_=(value: Ptr[struct__IO_FILE]): Unit = !(p._1 + 104).cast[Ptr[Ptr[struct__IO_FILE]]] = value.cast[Ptr[Byte]]
      def _fileno: CInt = !(p._1 + 112).cast[Ptr[CInt]]
      def _fileno_=(value: CInt): Unit = !(p._1 + 112).cast[Ptr[CInt]] = value
      def _flags2: CInt = !(p._1 + 116).cast[Ptr[CInt]]
      def _flags2_=(value: CInt): Unit = !(p._1 + 116).cast[Ptr[CInt]] = value
      def _old_offset: __off_t = !(p._1 + 120).cast[Ptr[__off_t]]
      def _old_offset_=(value: __off_t): Unit = !(p._1 + 120).cast[Ptr[__off_t]] = value
      def _cur_column: CUnsignedShort = !(p._1 + 128).cast[Ptr[CUnsignedShort]]
      def _cur_column_=(value: CUnsignedShort): Unit = !(p._1 + 128).cast[Ptr[CUnsignedShort]] = value
      def _vtable_offset: CSignedChar = !(p._1 + 130).cast[Ptr[CSignedChar]]
      def _vtable_offset_=(value: CSignedChar): Unit = !(p._1 + 130).cast[Ptr[CSignedChar]] = value
      def _shortbuf: Ptr[CArray[CChar, Nat._1]] = (p._1 + 131).cast[Ptr[CArray[CChar, Nat._1]]]
      def _shortbuf_=(value: Ptr[CArray[CChar, Nat._1]]): Unit = !(p._1 + 131).cast[Ptr[CArray[CChar, Nat._1]]] = !value
      def _lock: Ptr[Byte] = !(p._1 + 136).cast[Ptr[Ptr[Byte]]]
      def _lock_=(value: Ptr[Byte]): Unit = !(p._1 + 136).cast[Ptr[Ptr[Byte]]] = value
      def _offset: __off64_t = !(p._1 + 144).cast[Ptr[__off64_t]]
      def _offset_=(value: __off64_t): Unit = !(p._1 + 144).cast[Ptr[__off64_t]] = value
      def __pad1: Ptr[Byte] = !(p._1 + 152).cast[Ptr[Ptr[Byte]]]
      def __pad1_=(value: Ptr[Byte]): Unit = !(p._1 + 152).cast[Ptr[Ptr[Byte]]] = value
      def __pad2: Ptr[Byte] = !(p._1 + 160).cast[Ptr[Ptr[Byte]]]
      def __pad2_=(value: Ptr[Byte]): Unit = !(p._1 + 160).cast[Ptr[Ptr[Byte]]] = value
      def __pad3: Ptr[Byte] = !(p._1 + 168).cast[Ptr[Ptr[Byte]]]
      def __pad3_=(value: Ptr[Byte]): Unit = !(p._1 + 168).cast[Ptr[Ptr[Byte]]] = value
      def __pad4: Ptr[Byte] = !(p._1 + 176).cast[Ptr[Ptr[Byte]]]
      def __pad4_=(value: Ptr[Byte]): Unit = !(p._1 + 176).cast[Ptr[Ptr[Byte]]] = value
      def __pad5: CSize = !(p._1 + 184).cast[Ptr[CSize]]
      def __pad5_=(value: CSize): Unit = !(p._1 + 184).cast[Ptr[CSize]] = value
      def _mode: CInt = !(p._1 + 192).cast[Ptr[CInt]]
      def _mode_=(value: CInt): Unit = !(p._1 + 192).cast[Ptr[CInt]] = value
      def _unused2: Ptr[CArray[CChar, Nat.Digit[Nat._2, Nat._0]]] = (p._1 + 196).cast[Ptr[CArray[CChar, Nat.Digit[Nat._2, Nat._0]]]]
      def _unused2_=(value: Ptr[CArray[CChar, Nat.Digit[Nat._2, Nat._0]]]): Unit = !(p._1 + 196).cast[Ptr[CArray[CChar, Nat.Digit[Nat._2, Nat._0]]]] = !value
    }

    implicit class struct_pgNotify_ops(val p: Ptr[struct_pgNotify]) extends AnyVal {
      def relname: CString = !p._1
      def relname_=(value: CString): Unit = !p._1 = value
      def be_pid: CInt = !p._2
      def be_pid_=(value: CInt): Unit = !p._2 = value
      def extra: CString = !p._3
      def extra_=(value: CString): Unit = !p._3 = value
      def next: Ptr[struct_pgNotify] = (!p._4).cast[Ptr[struct_pgNotify]]
      def next_=(value: Ptr[struct_pgNotify]): Unit = !p._4 = value.cast[Ptr[Byte]]
    }

    implicit class struct__PQprintOpt_ops(val p: Ptr[struct__PQprintOpt]) extends AnyVal {
      def header: pqbool = !p._1
      def header_=(value: pqbool): Unit = !p._1 = value
      def align: pqbool = !p._2
      def align_=(value: pqbool): Unit = !p._2 = value
      def standard: pqbool = !p._3
      def standard_=(value: pqbool): Unit = !p._3 = value
      def html3: pqbool = !p._4
      def html3_=(value: pqbool): Unit = !p._4 = value
      def expanded: pqbool = !p._5
      def expanded_=(value: pqbool): Unit = !p._5 = value
      def pager: pqbool = !p._6
      def pager_=(value: pqbool): Unit = !p._6 = value
      def fieldSep: CString = !p._7
      def fieldSep_=(value: CString): Unit = !p._7 = value
      def tableOpt: CString = !p._8
      def tableOpt_=(value: CString): Unit = !p._8 = value
      def caption: CString = !p._9
      def caption_=(value: CString): Unit = !p._9 = value
      def fieldName: Ptr[CString] = !p._10
      def fieldName_=(value: Ptr[CString]): Unit = !p._10 = value
    }

    implicit class struct__PQconninfoOption_ops(val p: Ptr[struct__PQconninfoOption]) extends AnyVal {
      def keyword: CString = !p._1
      def keyword_=(value: CString): Unit = !p._1 = value
      def envvar: CString = !p._2
      def envvar_=(value: CString): Unit = !p._2 = value
      def compiled: CString = !p._3
      def compiled_=(value: CString): Unit = !p._3 = value
      def `val`: CString = !p._4
      def `val_=`(value: CString): Unit = !p._4 = value
      def label: CString = !p._5
      def label_=(value: CString): Unit = !p._5 = value
      def dispchar: CString = !p._6
      def dispchar_=(value: CString): Unit = !p._6 = value
      def dispsize: CInt = !p._7
      def dispsize_=(value: CInt): Unit = !p._7 = value
    }

    implicit class struct_PQArgBlock_ops(val p: Ptr[struct_PQArgBlock]) extends AnyVal {
      def len: CInt = !p._1
      def len_=(value: CInt): Unit = !p._1 = value
      def isint: CInt = !p._2
      def isint_=(value: CInt): Unit = !p._2 = value
      def u: Ptr[union_anonymous_1] = p._3
      def u_=(value: Ptr[union_anonymous_1]): Unit = !p._3 = !value
    }

    implicit class struct_pgresAttDesc_ops(val p: Ptr[struct_pgresAttDesc]) extends AnyVal {
      def name: CString = !p._1
      def name_=(value: CString): Unit = !p._1 = value
      def tableid: Oid = !p._2
      def tableid_=(value: Oid): Unit = !p._2 = value
      def columnid: CInt = !p._3
      def columnid_=(value: CInt): Unit = !p._3 = value
      def format: CInt = !p._4
      def format_=(value: CInt): Unit = !p._4 = value
      def typid: Oid = !p._5
      def typid_=(value: Oid): Unit = !p._5 = value
      def typlen: CInt = !p._6
      def typlen_=(value: CInt): Unit = !p._6 = value
      def atttypmod: CInt = !p._7
      def atttypmod_=(value: CInt): Unit = !p._7 = value
    }

    implicit class union_anonymous_1_pos(val p: Ptr[union_anonymous_1]) extends AnyVal {
      def ptr: Ptr[Ptr[CInt]] = p.cast[Ptr[Ptr[CInt]]]
      def ptr_=(value: Ptr[CInt]): Unit = !p.cast[Ptr[Ptr[CInt]]] = value
      def integer: Ptr[CInt] = p.cast[Ptr[CInt]]
      def integer_=(value: CInt): Unit = !p.cast[Ptr[CInt]] = value
    }
  }

  object struct__IO_marker {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct__IO_marker] = alloc[struct__IO_marker]
    def apply(_next: Ptr[struct__IO_marker], _sbuf: Ptr[struct__IO_FILE], _pos: CInt)(implicit z: Zone): Ptr[struct__IO_marker] = {
      val ptr = alloc[struct__IO_marker]
      ptr._next = _next
      ptr._sbuf = _sbuf
      ptr._pos = _pos
      ptr
    }
  }

  object struct__IO_FILE {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct__IO_FILE] = alloc[struct__IO_FILE]
    def apply(_flags: CInt, _IO_read_ptr: CString, _IO_read_end: CString, _IO_read_base: CString, _IO_write_base: CString, _IO_write_ptr: CString, _IO_write_end: CString, _IO_buf_base: CString, _IO_buf_end: CString, _IO_save_base: CString, _IO_backup_base: CString, _IO_save_end: CString, _markers: Ptr[struct__IO_marker], _chain: Ptr[struct__IO_FILE], _fileno: CInt, _flags2: CInt, _old_offset: __off_t, _cur_column: CUnsignedShort, _vtable_offset: CSignedChar, _shortbuf: Ptr[CArray[CChar, Nat._1]], _lock: Ptr[Byte], _offset: __off64_t, __pad1: Ptr[Byte], __pad2: Ptr[Byte], __pad3: Ptr[Byte], __pad4: Ptr[Byte], __pad5: CSize, _mode: CInt, _unused2: Ptr[CArray[CChar, Nat.Digit[Nat._2, Nat._0]]])(implicit z: Zone): Ptr[struct__IO_FILE] = {
      val ptr = alloc[struct__IO_FILE]
      ptr._flags = _flags
      ptr._IO_read_ptr = _IO_read_ptr
      ptr._IO_read_end = _IO_read_end
      ptr._IO_read_base = _IO_read_base
      ptr._IO_write_base = _IO_write_base
      ptr._IO_write_ptr = _IO_write_ptr
      ptr._IO_write_end = _IO_write_end
      ptr._IO_buf_base = _IO_buf_base
      ptr._IO_buf_end = _IO_buf_end
      ptr._IO_save_base = _IO_save_base
      ptr._IO_backup_base = _IO_backup_base
      ptr._IO_save_end = _IO_save_end
      ptr._markers = _markers
      ptr._chain = _chain
      ptr._fileno = _fileno
      ptr._flags2 = _flags2
      ptr._old_offset = _old_offset
      ptr._cur_column = _cur_column
      ptr._vtable_offset = _vtable_offset
      ptr._shortbuf = _shortbuf
      ptr._lock = _lock
      ptr._offset = _offset
      ptr.__pad1 = __pad1
      ptr.__pad2 = __pad2
      ptr.__pad3 = __pad3
      ptr.__pad4 = __pad4
      ptr.__pad5 = __pad5
      ptr._mode = _mode
      ptr._unused2 = _unused2
      ptr
    }
  }

  object struct_pgNotify {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct_pgNotify] = alloc[struct_pgNotify]
    def apply(relname: CString, be_pid: CInt, extra: CString, next: Ptr[struct_pgNotify])(implicit z: Zone): Ptr[struct_pgNotify] = {
      val ptr = alloc[struct_pgNotify]
      ptr.relname = relname
      ptr.be_pid = be_pid
      ptr.extra = extra
      ptr.next = next
      ptr
    }
  }

  object struct__PQprintOpt {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct__PQprintOpt] = alloc[struct__PQprintOpt]
    def apply(header: pqbool, align: pqbool, standard: pqbool, html3: pqbool, expanded: pqbool, pager: pqbool, fieldSep: CString, tableOpt: CString, caption: CString, fieldName: Ptr[CString])(implicit z: Zone): Ptr[struct__PQprintOpt] = {
      val ptr = alloc[struct__PQprintOpt]
      ptr.header = header
      ptr.align = align
      ptr.standard = standard
      ptr.html3 = html3
      ptr.expanded = expanded
      ptr.pager = pager
      ptr.fieldSep = fieldSep
      ptr.tableOpt = tableOpt
      ptr.caption = caption
      ptr.fieldName = fieldName
      ptr
    }
  }

  object struct__PQconninfoOption {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct__PQconninfoOption] = alloc[struct__PQconninfoOption]
    def apply(keyword: CString, envvar: CString, compiled: CString, `val`: CString, label: CString, dispchar: CString, dispsize: CInt)(implicit z: Zone): Ptr[struct__PQconninfoOption] = {
      val ptr = alloc[struct__PQconninfoOption]
      ptr.keyword = keyword
      ptr.envvar = envvar
      ptr.compiled = compiled
      ptr.`val` = `val`
      ptr.label = label
      ptr.dispchar = dispchar
      ptr.dispsize = dispsize
      ptr
    }
  }

  object struct_PQArgBlock {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct_PQArgBlock] = alloc[struct_PQArgBlock]
    def apply(len: CInt, isint: CInt, u: Ptr[union_anonymous_1])(implicit z: Zone): Ptr[struct_PQArgBlock] = {
      val ptr = alloc[struct_PQArgBlock]
      ptr.len = len
      ptr.isint = isint
      ptr.u = u
      ptr
    }
  }

  object struct_pgresAttDesc {
    import implicits._
    def apply()(implicit z: Zone): Ptr[struct_pgresAttDesc] = alloc[struct_pgresAttDesc]
    def apply(name: CString, tableid: Oid, columnid: CInt, format: CInt, typid: Oid, typlen: CInt, atttypmod: CInt)(implicit z: Zone): Ptr[struct_pgresAttDesc] = {
      val ptr = alloc[struct_pgresAttDesc]
      ptr.name = name
      ptr.tableid = tableid
      ptr.columnid = columnid
      ptr.format = format
      ptr.typid = typid
      ptr.typlen = typlen
      ptr.atttypmod = atttypmod
      ptr
    }
  }*/
}

